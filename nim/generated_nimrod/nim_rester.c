/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <setjmp.h>

#include <sys/time.h>

#include <stdio.h>
typedef struct globalstate140012 globalstate140012;
typedef struct tstringtable113610 tstringtable113610;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TY103885 TY103885;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TSafePoint TSafePoint;
typedef struct trstgenerator127012 trstgenerator127012;
typedef struct TY127028 TY127028;
typedef struct ttocentry127008 ttocentry127008;
typedef struct trstnode115012 trstnode115012;
typedef struct tstringstream129435 tstringstream129435;
typedef struct einvalidvalue1253 einvalidvalue1253;
typedef struct esynch1229 esynch1229;
typedef struct tcell40090 tcell40090;
typedef struct tcellseq40106 tcellseq40106;
typedef struct tgcheap42016 tgcheap42016;
typedef struct tcellset40102 tcellset40102;
typedef struct tpagedesc40098 tpagedesc40098;
typedef struct tmemregion23010 tmemregion23010;
typedef struct tsmallchunk22238 tsmallchunk22238;
typedef struct tllchunk23004 tllchunk23004;
typedef struct tbigchunk22240 tbigchunk22240;
typedef struct tintset22215 tintset22215;
typedef struct ttrunk22211 ttrunk22211;
typedef struct tavlnode23008 tavlnode23008;
typedef struct tgcstat42014 tgcstat42014;
typedef struct tcfgparser132612 tcfgparser132612;
typedef struct tbaselexer130008 tbaselexer130008;
typedef struct tstream129037 tstream129037;
typedef struct ttoken132610 ttoken132610;
typedef struct tcfgevent132606 tcfgevent132606;
typedef struct TY89506 TY89506;
typedef struct ttimeinfo89403 ttimeinfo89403;
typedef struct tlogger139024 tlogger139024;
typedef struct trollingfilelogger139030 trollingfilelogger139030;
typedef struct tfilelogger139028 tfilelogger139028;
typedef struct tconsolelogger139026 tconsolelogger139026;
typedef struct tkeyvaluepairseq113608 tkeyvaluepairseq113608;
typedef struct trstnodeseq115010 trstnodeseq115010;
typedef struct tbasechunk22236 tbasechunk22236;
typedef struct tfreecell22228 tfreecell22228;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY613[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY613 data;
};
struct globalstate140012 {
tstringtable113610* Config;
NimStringDesc* Lastcconversion;
NimStringDesc* Basedir;
};
struct TY103885 {
NimStringDesc* Field0;
NimStringDesc* Field1;
NimStringDesc* Field2;
};
typedef N_NIMCALL_PTR(void, TY1089) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY1089 marker;
};
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (E_Base* e, void* ClEnv);
void* ClEnv;
} TY11426;
struct TSafePoint {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY11426 raiseAction;
};
struct ttocentry127008 {
trstnode115012* N;
NimStringDesc* Refname;
NimStringDesc* Header;
};
typedef N_NIMCALL_PTR(NimStringDesc*, tfindfilehandler116016) (NimStringDesc* filename);
typedef N_NIMCALL_PTR(void, tmsghandler116014) (NimStringDesc* filename, NI line, NI col, NU8 msgkind, NimStringDesc* arg);
typedef NimStringDesc* TY127036[5];
struct trstgenerator127012 {
  TNimObject Sup;
NU8 Target;
tstringtable113610* Config;
NI Splitafter;
TY127028* Tocpart;
NIM_BOOL Hastoc;
NimStringDesc* Theindex;
NU8 Options;
tfindfilehandler116016 Findfile;
tmsghandler116014 Msghandler;
NimStringDesc* Filename;
TY127036 Meta;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct esynch1229 {
  E_Base Sup;
};
struct einvalidvalue1253 {
  esynch1229 Sup;
};
struct tcell40090 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq40106 {
NI Len;
NI Cap;
tcell40090** D;
};
struct tcellset40102 {
NI Counter;
NI Max;
tpagedesc40098* Head;
tpagedesc40098** Data;
};
typedef tsmallchunk22238* TY23022[512];
typedef ttrunk22211* ttrunkbuckets22213[256];
struct tintset22215 {
ttrunkbuckets22213 Data;
};
struct tmemregion23010 {
NI Minlargeobj;
NI Maxlargeobj;
TY23022 Freesmallchunks;
tllchunk23004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk22240* Freechunkslist;
tintset22215 Chunkstarts;
tavlnode23008* Root;
tavlnode23008* Deleted;
tavlnode23008* Last;
tavlnode23008* Freeavlnodes;
};
struct tgcstat42014 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap42016 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq40106 Zct;
tcellseq40106 Decstack;
tcellset40102 Cycleroots;
tcellseq40106 Tempstack;
NI Recgclock;
tmemregion23010 Region;
tgcstat42014 Stat;
};
struct tbaselexer130008 {
  TNimObject Sup;
NI Bufpos;
NCSTRING Buf;
NI Buflen;
tstream129037* Input;
NI Linenumber;
NI Sentinel;
NI Linestart;
NIM_BOOL Fileopened;
};
struct ttoken132610 {
NU8 Kind;
NimStringDesc* Literal;
};
struct tcfgparser132612 {
  tbaselexer130008 Sup;
ttoken132610 Tok;
NimStringDesc* Filename;
};
struct tcfgevent132606 {
  TNimObject Sup;
NU8 Kind;
union {
struct {NimStringDesc* Section;
} S2;
struct {NimStringDesc* Key;
NimStringDesc* Value;
} S3;
struct {NimStringDesc* Msg;
} S4;
} kindU;
};
typedef NimStringDesc* TY140177[1];
struct TY89506 {
NimStringDesc* Field0;
NimStringDesc* Field1;
};
struct ttimeinfo89403 {
  TNimObject Sup;
NI Second;
NI Minute;
NI Hour;
NI Monthday;
NU8 Month;
NI Year;
NU8 Weekday;
NI Yearday;
NIM_BOOL Isdst;
NimStringDesc* Tzname;
NI Timezone;
};
typedef NimStringDesc* TY140664[8];
struct tstringtable113610 {
  TNimObject Sup;
NI Counter;
tkeyvaluepairseq113608* Data;
NU8 Mode;
};
struct trstnode115012 {
NU8 Kind;
NimStringDesc* Text;
NI Level;
trstnodeseq115010* Sons;
};
typedef N_NIMCALL_PTR(void, TY129038) (tstream129037* s);
typedef N_NIMCALL_PTR(NIM_BOOL, TY129042) (tstream129037* s);
typedef N_NIMCALL_PTR(void, TY129046) (tstream129037* s, NI pos);
typedef N_NIMCALL_PTR(NI, TY129051) (tstream129037* s);
typedef N_NIMCALL_PTR(NI, TY129055) (tstream129037* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY129061) (tstream129037* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY129067) (tstream129037* s);
struct tstream129037 {
  TNimObject Sup;
TY129038 Closeimpl;
TY129042 Atendimpl;
TY129046 Setpositionimpl;
TY129051 Getpositionimpl;
TY129055 Readdataimpl;
TY129061 Writedataimpl;
TY129067 Flushimpl;
};
struct tstringstream129435 {
  tstream129037 Sup;
NimStringDesc* Data;
NI Pos;
};
typedef NI TY22218[8];
struct tpagedesc40098 {
tpagedesc40098* Next;
NI Key;
TY22218 Bits;
};
struct tbasechunk22236 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk22238 {
  tbasechunk22236 Sup;
tsmallchunk22238* Next;
tsmallchunk22238* Prev;
tfreecell22228* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct tllchunk23004 {
NI Size;
NI Acc;
tllchunk23004* Next;
};
struct tbigchunk22240 {
  tbasechunk22236 Sup;
tbigchunk22240* Next;
tbigchunk22240* Prev;
NI Align;
NF Data;
};
struct ttrunk22211 {
ttrunk22211* Next;
NI Key;
TY22218 Bits;
};
typedef tavlnode23008* TY23014[2];
struct tavlnode23008 {
TY23014 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tlogger139024 {
  TNimObject Sup;
NU8 Levelthreshold;
NimStringDesc* Fmtstr;
};
struct tfilelogger139028 {
  tlogger139024 Sup;
FILE* F;
};
struct trollingfilelogger139030 {
  tfilelogger139028 Sup;
NI Maxlines;
NI Curline;
NimStringDesc* Basename;
NI Logfiles;
};
struct tconsolelogger139026 {
  tlogger139024 Sup;
};
struct tfreecell22228 {
tfreecell22228* Next;
NI Zerofield;
};
struct TY127028 {
  TGenericSeq Sup;
  ttocentry127008 data[SEQ_DECL_SIZE];
};
struct tkeyvaluepairseq113608 {
  TGenericSeq Sup;
  TY89506 data[SEQ_DECL_SIZE];
};
struct trstnodeseq115010 {
  TGenericSeq Sup;
  trstnode115012* data[SEQ_DECL_SIZE];
};
N_NIMCALL(NI, txt_to_rst)(NCSTRING inputfilename);
N_NIMCALL(NimStringDesc*, cstrToNimstr)(NCSTRING str);
N_NIMCALL(void, nossplitFile)(NimStringDesc* path, TY103885* Result);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
N_NIMCALL(NimStringDesc*, nimfiletohtml_140692)(NimStringDesc* filename);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(NimStringDesc*, nsuRepeatChar)(NI count, NIM_CHAR c);
N_NIMCALL(NI64, nosgetFileSize)(NimStringDesc* file);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, nsuReplaceStr)(NimStringDesc* s, NimStringDesc* sub, NimStringDesc* by);
N_NIMCALL(NimStringDesc*, readfile_10240)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(NimStringDesc*, rststringtohtml_140307)(NimStringDesc* content, NimStringDesc* filename);
N_NIMCALL(tstringtable113610*, loadconfig_140020)(NimStringDesc* memstring);
N_NIMCALL(tstringtable113610*, nstnewStringTable)(NU8 mode);
N_NIMCALL(tstringstream129435*, newstringstream_129536)(NimStringDesc* s);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell40090*, usrtocell_43442)(void* usr);
static N_INLINE(void, rtladdzct_45002)(tcell40090* c);
N_NOINLINE(void, addzct_43418)(tcellseq40106* s, tcell40090* c);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
N_NIMCALL(void, npcopen)(tcfgparser132612* c, tstream129037* input, NimStringDesc* filename, NI lineoffset);
N_NIMCALL(void, npcnext)(tcfgparser132612* c, tcfgevent132606* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, nstPut)(tstringtable113610* t, NimStringDesc* key, NimStringDesc* val);
N_NIMCALL(void, logloop_139319)(NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, npcclose)(tcfgparser132612* c);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void, nossplitPath)(NimStringDesc* path, TY89506* Result);
N_NIMCALL(void, initrstgenerator_127040)(trstgenerator127012* g, NU8 target, tstringtable113610* config, NimStringDesc* filename, NU8 options, tfindfilehandler116016 findfile, tmsghandler116014 msghandler);
N_NIMCALL(NimStringDesc*, myfindfile_140601)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, HEX2F_103673)(NimStringDesc* head, NimStringDesc* tail);
N_NIMCALL(NIM_BOOL, nosexistsFile)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(void, defaultmsghandler_116803)(NimStringDesc* filename, NI line, NI col, NU8 msgkind, NimStringDesc* arg);
N_NIMCALL(trstnode115012*, rstparse_122542)(NimStringDesc* text, NimStringDesc* filename, NI line, NI column, NIM_BOOL* hastoc, NU8 options, tfindfilehandler116016 findfile, tmsghandler116014 msghandler);
N_NIMCALL(void, renderrsttoout_127329)(trstgenerator127012* d, trstnode115012* n, NimStringDesc** result);
N_NIMCALL(void, getgmtime_89445)(time_t t, ttimeinfo89403* Result);
N_NIMCALL(time_t, nosgetLastModificationTime)(NimStringDesc* file);
N_NIMCALL(NimStringDesc*, nfrmtFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, subex_135519)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nstGet)(tstringtable113610* t, NimStringDesc* key);
N_NIMCALL(NimStringDesc*, format_91395)(ttimeinfo89403* info, NimStringDesc* f);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(E_Base*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(NimStringDesc*, saferstfiletohtml_140676)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, rstfiletohtml_140670)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, xmlencode_137271)(NimStringDesc* s);
static N_INLINE(NimStringDesc*, getcurrentexceptionmsg_76235)(void);
N_NIMCALL(NimStringDesc*, reprAny)(void* p_74003, TNimType* typ);
N_NIMCALL(void, get_global_html)(void* outputbuffer);
N_NIMCALL(void, quit_77030)(NimStringDesc* errormsg, NI errorcode);
N_NIMCALL(void, log_139266)(trollingfilelogger139030* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, log_139150)(tfilelogger139028* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, log_139124)(tconsolelogger139026* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, log_139111)(tlogger139024* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
static N_INLINE(void, initStackBottom)(void);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
N_NOINLINE(void, systemInit)(void);
N_NOINLINE(void, systemDatInit)(void);
N_NOINLINE(void, pureparseutilsInit)(void);
N_NOINLINE(void, pureparseutilsDatInit)(void);
N_NOINLINE(void, purestrutilsInit)(void);
N_NOINLINE(void, purestrutilsDatInit)(void);
N_NOINLINE(void, puretimesInit)(void);
N_NOINLINE(void, puretimesDatInit)(void);
N_NOINLINE(void, posixposixInit)(void);
N_NOINLINE(void, posixposixDatInit)(void);
N_NOINLINE(void, pureosInit)(void);
N_NOINLINE(void, pureosDatInit)(void);
N_NOINLINE(void, purehashesInit)(void);
N_NOINLINE(void, purehashesDatInit)(void);
N_NOINLINE(void, purestrtabsInit)(void);
N_NOINLINE(void, purestrtabsDatInit)(void);
N_NOINLINE(void, docutilsrstastInit)(void);
N_NOINLINE(void, docutilsrstastDatInit)(void);
N_NOINLINE(void, docutilsrstInit)(void);
N_NOINLINE(void, docutilsrstDatInit)(void);
N_NOINLINE(void, docutilshighliteInit)(void);
N_NOINLINE(void, docutilshighliteDatInit)(void);
N_NOINLINE(void, docutilsrstgenInit)(void);
N_NOINLINE(void, docutilsrstgenDatInit)(void);
N_NOINLINE(void, purestreamsInit)(void);
N_NOINLINE(void, purestreamsDatInit)(void);
N_NOINLINE(void, purelexbaseInit)(void);
N_NOINLINE(void, purelexbaseDatInit)(void);
N_NOINLINE(void, pureparsecfgInit)(void);
N_NOINLINE(void, pureparsecfgDatInit)(void);
N_NOINLINE(void, puresubexesInit)(void);
N_NOINLINE(void, puresubexesDatInit)(void);
N_NOINLINE(void, purecookiesInit)(void);
N_NOINLINE(void, purecookiesDatInit)(void);
N_NOINLINE(void, purecgiInit)(void);
N_NOINLINE(void, purecgiDatInit)(void);
N_NOINLINE(void, nimloggingInit)(void);
N_NOINLINE(void, nimloggingDatInit)(void);
N_NOINLINE(void, resterInit)(void);
N_NOINLINE(void, resterDatInit)(void);
STRING_LITERAL(TMP85, ".nim", 4);
STRING_LITERAL(TMP95, "\012", 1);
STRING_LITERAL(TMP96, "\012.. code-block:: nimrod\012  ", 26);
STRING_LITERAL(TMP103, "\012  ", 3);
STRING_LITERAL(TMP129, "cannot stream string", 20);
STRING_LITERAL(TMP144, "static slurped config", 21);
STRING_LITERAL(TMP153, "command: ", 9);
STRING_LITERAL(TMP154, ": ", 2);
STRING_LITERAL(TMP155, "# This is the config file for the documentation generator.\012# (c"
") 2012 Andreas Rumpf\012# Feel free to edit the templates as you ne"
"ed.\012\012split.item.toc = \"20\"  \012# too long entries in the table of "
"contents wrap around\012# after this number of characters\012\012doc.sect"
"ion = \"\"\"\012<div class=\"section\" id=\"$sectionID\">\012<h1><a class=\"to"
"c-backref\" href=\"#$sectionTitleID\">$sectionTitle</a></h1>\012<dl cl"
"ass=\"item\">\012$content\012</dl></div>\012\"\"\"\012\012doc.section.toc = \"\"\"\012<li>"
"\012  <a class=\"reference\" href=\"#$sectionID\" id=\"$sectionTitleID\">"
"$sectionTitle</a>\012  <ul class=\"simple\">\012    $content\012  </ul>\012</l"
"i>\012\"\"\"\012\012doc.item = \"\"\"\012<dt id=\"$itemID\"><pre>$header</pre></dt>\012"
"<dd>\012$desc\012</dd>\012\"\"\"\012\012doc.item.toc = \"\"\"\012  <li><a class=\"referen"
"ce\" href=\"#$itemID\">$name</a></li>\012\"\"\"\012\012doc.toc = \"\"\"\012<div class"
"=\"navigation\" id=\"navigation\">\012<ul class=\"simple\">\012$content\012</ul"
">\012</div>\"\"\"\012\012doc.body_toc = \"\"\"\012$tableofcontents\012<div class=\"con"
"tent\" id=\"content\">\012$moduledesc\012$content\012</div>\012\"\"\"\012\012doc.body_no"
"_toc = \"\"\"\012$moduledesc\012$content\012\"\"\"\012\012doc.file = \"\"\"<?xml version"
"=\"1.0\" encoding=\"utf-8\" ?>\012<!DOCTYPE html PUBLIC \"-//W3C//DTD XH"
"TML 1.0 Transitional//EN\"\012  \"http://www.w3.org/TR/xhtml1/DTD/xht"
"ml1-transitional.dtd\">\012<!--  This file is generated by Nimrod. -"
"->\012<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang"
"=\"en\">\012<head>\012<meta http-equiv=\"Content-Type\" content=\"text/html"
"; charset=utf-8\" />\012<title>$title</title>\012<style type=\"text/css\""
">\012\012span.DecNumber {color: blue}\012span.BinNumber {color: blue}\012spa"
"n.HexNumber {color: blue}\012span.OctNumber {color: blue}\012span.Floa"
"tNumber {color: blue}\012span.Identifier  {color: black}\012span.Keywo"
"rd {font-weight: bold}\012span.StringLit {color: blue}\012span.LongStr"
"ingLit {color: blue}\012span.CharLit {color: blue}\012span.EscapeSeque"
"nce {color: black}\012span.Operator {color: black}\012span.Punctation "
"{color: black}\012span.Comment, span.LongComment {font-style:italic"
"; color: green}\012span.RegularExpression  {color: DarkViolet}\012span"
".TagStart {color: DarkViolet}\012span.TagEnd {color: DarkViolet}\012sp"
"an.Key  {color: blue}\012span.Value  {color: black}\012span.RawData {c"
"olor: blue}\012span.Assembler  {color: blue}\012span.Preprocessor {col"
"or: DarkViolet}\012span.Directive  {color: DarkViolet}\012span.Command"
", span.Rule, span.Hyperlink, span.Label, span.Reference, \012span.O"
"ther  {color: black}\012\012div.navigation {\012  -moz-border-radius: 5px"
" 5px 5px 5px;\012  float: left; \012  width: 30%;\012  margin: 0; padding"
": 0;\012  border: 3px outset #7F7F7F;\012  background-color: #7F7F7F;\012"
"}\012\012div.navigation ul {\012  list-style-type: none;\012  padding-left: "
"1em;\012}\012div.navigation ul li a, div.navigation ul li a:visited {\012"
"  font-weight: bold;\012  color: #FFFFFF;\012  text-decoration: none;\012"
"}\012div.navigation ul li a:hover {\012  font-weight: bold;\012  text-dec"
"oration: none;\012  color: gold;\012}\012\012div.content {\012  margin-left: 30"
"%;\012  padding: 0 1em;\012  border-left: 4em;\012}\012\012dl.item dd, dl.item "
"dd p {\012  margin-top:3px;\012}\012dl.item dd pre {\012  margin-left: 15pt;"
"\012  border: 0px;\012}\012dl.item dt, dl.item dt pre {\012  margin:  20pt 0"
" 0 5pt;\012}\012\012pre, span.tok {\012  background-color: #F9F9F9;\012  border"
"-color: #C4C4C4;\012  border-style: solid;\012  border-width: 1px 1px "
"1px 2px;\012  color: black;\012  line-spacing: 110%;\012  padding: 2px;\012}"
"\012\012span.red {\012  color: #A80000;\012}\012\012hr {background-color:#9D9D9D; "
"border:0 none; color:#9D9D9D; height:1px; width:100%;}\012\012/*\012:Auth"
"or: David Goodger\012:Contact: goodger@python.org\012:Date: Date: 2006"
"-05-21 22:44:42 +0200 (Sun, 21 May 2006)\012:Revision: Revision: 45"
"64\012:Copyright: This stylesheet has been placed in the public dom"
"ain.\012\012Default cascading style sheet for the HTML output of Docut"
"ils.\012\012See http://docutils.sf.net/docs/howto/html-stylesheets.htm"
"l for how to\012customize this style sheet.\012*/\012/* used to remove bo"
"rders from tables and images */\012.borderless, table.borderless td"
", table.borderless th { border: 0 }\012\012table.borderless td, table."
"borderless th {\012  /* Override padding for \"table.docutils td\" wi"
"th \"! important\".\012     The right padding separates the table cel"
"ls. */\012  padding: 0 0.5em 0 0 ! important }\012\012.first { margin-top"
": 0 ! important }\012.last, .with-subtitle { margin-bottom: 0 ! imp"
"ortant }\012.hidden { display: none }\012a.toc-backref { text-decorati"
"on: none ; color: black }\012blockquote.epigraph { margin: 2em 5em "
"; }\012dl.docutils dd { margin-bottom: 0.5em }\012div.abstract { margi"
"n: 2em 5em }\012div.abstract p.topic-title { font-weight: bold ; te"
"xt-align: center }\012div.admonition, div.attention, div.caution, d"
"iv.danger, div.error,\012div.hint, div.important, div.note, div.tip"
", div.warning {\012  margin: 2em ; border: medium outset ; padding:"
" 1em }\012div.admonition p.admonition-title, div.hint p.admonition-"
"title,\012div.important p.admonition-title, div.note p.admonition-t"
"itle,\012div.tip p.admonition-title { font-weight: bold ; font-fami"
"ly: sans-serif }\012\012div.attention p.admonition-title, div.caution "
"p.admonition-title,\012div.danger p.admonition-title, div.error p.a"
"dmonition-title,\012div.warning p.admonition-title { color: red ; f"
"ont-weight: bold ;\012  font-family: sans-serif }\012\012/* Uncomment (an"
"d remove this text!) to get reduced vertical space in\012   compoun"
"d paragraphs.\012div.compound .compound-first, div.compound .compou"
"nd-middle {\012  margin-bottom: 0.5em }\012\012div.compound .compound-las"
"t, div.compound .compound-middle {\012  margin-top: 0.5em }\012*/\012\012div"
".dedication { margin: 2em 5em ; text-align: center ; font-style:"
" italic }\012div.dedication p.topic-title { font-weight: bold ; fon"
"t-style: normal }\012div.figure { margin-left: 2em ; margin-right: "
"2em }\012div.footer, div.header { clear: both; font-size: smaller }"
"\012div.line-block { display: block ; margin-top: 1em ; margin-bott"
"om: 1em }\012div.line-block div.line-block { margin-top: 0 ; margin"
"-bottom: 0 ;\012  margin-left: 1.5em }\012div.sidebar { margin-left: 1"
"em ; border: medium outset ;\012  padding: 1em ; background-color: "
"#ffffee ; /*width: 40% ;*/ float: right ;\012  clear: right }\012\012div."
"sidebar p.rubric { font-family: sans-serif ; font-size: medium }"
"\012div.system-messages { margin: 5em }\012div.system-messages h1 { co"
"lor: red }\012div.system-message { border: medium outset ; padding:"
" 1em }\012div.system-message p.system-message-title { color: red ; "
"font-weight: bold }\012div.topic { margin: 2em;}\012h1.section-subtitl"
"e, h2.section-subtitle, h3.section-subtitle,\012h4.section-subtitle"
", h5.section-subtitle, h6.section-subtitle {\012  margin-top: 0.4em"
" }\012h1.title { text-align: center }\012h2.subtitle { text-align: cen"
"ter }\012/* hr.docutils { width: 75% } */\012img.align-left { clear: l"
"eft }\012img.align-right { clear: right }\012ol.simple, ul.simple { ma"
"rgin-bottom: 1em }\012ol.arabic { list-style: decimal }\012ol.loweralp"
"ha { list-style: lower-alpha }\012ol.upperalpha { list-style: upper"
"-alpha }\012ol.lowerroman { list-style: lower-roman }\012ol.upperroman"
" { list-style: upper-roman }\012p.attribution { text-align: right ;"
" margin-left: 50% }\012p.caption { font-style: italic }\012p.credits {"
" font-style: italic ; font-size: smaller }\012p.label { white-space"
": nowrap }\012p.rubric { font-weight:bold;font-size:larger;color:ma"
"roon;text-align:center}\012p.sidebar-title {font-family: sans-serif"
" ;font-weight: bold ;font-size: larger }\012p.sidebar-subtitle {fon"
"t-family: sans-serif ; font-weight: bold }\012p.topic-title {\012font-"
"weight: bold;\012background-color: #6D6D6D;\012border-bottom: 1px soli"
"d #000000;\012border-top: 1px solid black;\012color: white;\012text-align"
": center;\012margin: 0;\012}\012pre.address { margin-bottom: 0;margin-top"
":0;font-family:serif;font-size:100% }\012pre.literal-block, pre.doc"
"test-block {margin-left: 2em ;margin-right: 2em }\012span.classifie"
"r {font-family: sans-serif;font-style: oblique }\012span.classifier"
"-delimiter {font-family: sans-serif;font-weight: bold }\012span.int"
"erpreted {font-family: sans-serif }\012span.option {white-space: no"
"wrap }\012span.pre {white-space: pre }\012span.problematic {color: red"
" }\012span.section-subtitle {\012  /* font-size relative to parent (h1"
"..h6 element) */\012  font-size: 80% }\012\012table.citation { border-lef"
"t: solid 1px gray; margin-left: 1px }\012table.docinfo {margin: 2em"
" 4em }\012table.docutils {margin-top: 0.5em;margin-bottom: 0.5em; b"
"order: 0 solid #9d9d9d; border-collapse: collapse; }\012table.footn"
"ote {border-left: solid 1px black;margin-left: 1px }\012\012table.docu"
"tils td, table.docutils th,\012table.docinfo td, table.docinfo th {"
"padding-left: 0.5em;padding-right: 0.5em;\012  vertical-align: top;"
"}\012\012table.docutils td, table.docutils th { border-bottom:1px soli"
"d #9D9D9D; }\012/* color: #4d4d4d} */\012\012/* table.docutils td:hover, "
"table.docinfo td:hover {color: #000000} */\012  \012\012table.docutils th"
".field-name, table.docinfo th.docinfo-name {\012  font-weight: bold"
";text-align: left;white-space: nowrap;padding-left: 0 }\012  \012table"
".docutils th\012{\012color: black;\012font-weight:normal;\012background-colo"
"r: #E3E3E3;\012border-top: 1px solid #1d1d1d;\012border-bottom: 1px so"
"lid #1d1d1d;\012}\012  \012h1 tt.docutils, h2 tt.docutils, h3 tt.docutils"
",\012h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {font-size: 100"
"% }\012ul.auto-toc { list-style-type: none }\012/*a.reference { color:"
" #E00000; font-weight:bold;}\012a.reference:hover {color: #E00000;b"
"ackground-color: #ffff00;display: margin;\012  font-weight:bold;}*/"
"\012\012</style>\012\012</head>\012<body>\012<div class=\"document\" id=\"documentId\""
">\012<h1 class=\"title\">$title</h1>\012$content\012<small>Last modified: $"
"date $time UTC</small>\012</div>\012</body>\012</html>\012\"\"\"\012", 9073);
STRING_LITERAL(TMP166, "Asking for \'", 12);
STRING_LITERAL(TMP167, "\'", 1);
STRING_LITERAL(TMP168, "Global is \'", 11);
STRING_LITERAL(TMP169, "Returning \'", 11);
STRING_LITERAL(TMP170, "", 0);
STRING_LITERAL(TMP668, "doc.file", 8);
STRING_LITERAL(TMP669, "title", 5);
STRING_LITERAL(TMP670, "date", 4);
STRING_LITERAL(TMP723, "yyyy-MM-dd", 10);
STRING_LITERAL(TMP724, "time", 4);
STRING_LITERAL(TMP725, "HH:MM", 5);
STRING_LITERAL(TMP726, "content", 7);
STRING_LITERAL(TMP727, "<html><body><h1>Error for ", 26);
STRING_LITERAL(TMP728, "</h1></body></html>", 19);
STRING_LITERAL(TMP729, "<html><body><h1>OS error for ", 29);
STRING_LITERAL(TMP730, "<html><body><h1>I/O error for ", 30);
STRING_LITERAL(TMP731, "<html><body><h1>Out of memory!</h1></body></html>", 49);
STRING_LITERAL(TMP738, "Could not read ", 15);
STRING_LITERAL(TMP739, "!!!", 3);
STRING_LITERAL(TMP740, "<html><body><b>Sorry! Error parsing ", 36);
STRING_LITERAL(TMP741, " with version 0.4.0.</b><p>If possible please report it at <a h"
"ref=\"https://github.com/gradha/quicklook-rest-with-nimrod/issues"
"\">https://github.com/gradha/quicklook-rest-with-nimrod/issues</a"
"><p>", 195);
STRING_LITERAL(TMP764, " with message \'", 15);
STRING_LITERAL(TMP765, "\'</p><p>Displaying raw contents of file anyway:</p><p><tt>", 58);
STRING_LITERAL(TMP766, "<br>", 4);
STRING_LITERAL(TMP767, "</tt></p></body></html>", 23);
STRING_LITERAL(TMP768, "Uh oh, wrong API usage", 22);
globalstate140012 g_140017;
extern TSafePoint* exchandler_12838;
extern TNimType NTI116006; /* TRstParseOption */
TNimType NTI140312; /* set[TRstParseOption] */
extern TNimType NTI127012; /* TRstGenerator */
extern TNimType NTI17401; /* ref EInvalidValue */
extern TNimType NTI1253; /* EInvalidValue */
extern tgcheap42016 gch_42044;
extern TNimType NTI132612; /* TCfgParser */
extern TNimType NTI132606; /* TCfgEvent */
extern NU8 level_139293;
extern TNimType NTI89403; /* TTimeInfo */
extern TNimType NTI1225; /* E_Base */
extern E_Base* currexception_12840;
extern TNimType NTI1235; /* EOS */
extern TNimType NTI1233; /* EIO */
extern TNimType NTI1257; /* EOutOfMemory */
extern TNimType NTI6416; /* ref E_Base */
extern TNimType NTI139030; /* TRollingFileLogger */
extern TNimType NTI139028; /* TFileLogger */
extern TNimType NTI139026; /* TConsoleLogger */
extern TNimType NTI139024; /* TLogger */

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
	int LOC13;
	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = 0;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = 0;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC13 = 0;
	LOC13 = memcmp(((NCSTRING) ((*a).data)), ((NCSTRING) ((*b).data)), (NI64)((*a).Sup.len * 1));
	LOC11 = (LOC13 == ((NI32) 0));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_12838;
	exchandler_12838 = s;
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(tcell40090*, usrtocell_43442)(void* usr) {
	tcell40090* result;
	result = 0;
	result = ((tcell40090*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell40090))))));
	return result;
}

static N_INLINE(void, rtladdzct_45002)(tcell40090* c) {
	addzct_43418(&gch_42044.Zct, c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell40090* c;
	c = usrtocell_43442(p);
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_45002(c);
	}
	LA3: ;
}

N_NIMCALL(tstringtable113610*, loadconfig_140020)(NimStringDesc* memstring) {
	tstringtable113610* result;
	tstringstream129435* f;
	tcfgparser132612 p;
	result = 0;
	result = nstnewStringTable(((NU8) 2));
	f = newstringstream_129536(memstring);
	{
		einvalidvalue1253* e_140037;
		NimStringDesc* LOC5;
		if (!f == 0) goto LA3;
		e_140037 = 0;
		e_140037 = (einvalidvalue1253*) newObj((&NTI17401), sizeof(einvalidvalue1253));
		(*e_140037).Sup.Sup.Sup.m_type = (&NTI1253);
		LOC5 = 0;
		LOC5 = (*e_140037).Sup.Sup.message; (*e_140037).Sup.Sup.message = copyStringRC1(((NimStringDesc*) &TMP129));
		if (LOC5) nimGCunrefNoCycle(LOC5);
		raiseException((E_Base*)e_140037, "EInvalidValue");
	}
	LA3: ;
	memset((void*)&p, 0, sizeof(p));
	p.Sup.Sup.m_type = (&NTI132612);
	npcopen(&p, &f->Sup, ((NimStringDesc*) &TMP144), 0);
	while (1) {
		tcfgevent132606 e_140058;
		chckNil((void*)&e_140058);
		memset((void*)&e_140058, 0, sizeof(e_140058));
		e_140058.Sup.m_type = (&NTI132606);
		npcnext(&p, &e_140058);
		switch (e_140058.Kind) {
		case ((NU8) 0):
		{
			goto LA6;
		}
		break;
		case ((NU8) 1):
		{
		}
		break;
		case ((NU8) 2):
		{
			nstPut(result, e_140058.kindU.S3.Key, e_140058.kindU.S3.Value);
		}
		break;
		case ((NU8) 3):
		{
			{
				NimStringDesc* LOC15;
				TY140177 LOC16;
				if (!(level_139293 <= ((NU8) 3))) goto LA13;
				LOC15 = 0;
				LOC15 = rawNewString(e_140058.kindU.S3.Key->Sup.len + e_140058.kindU.S3.Value->Sup.len + 11);
appendString(LOC15, ((NimStringDesc*) &TMP153));
appendString(LOC15, e_140058.kindU.S3.Key);
appendString(LOC15, ((NimStringDesc*) &TMP154));
appendString(LOC15, e_140058.kindU.S3.Value);
				memset((void*)LOC16, 0, sizeof(LOC16));
				logloop_139319(((NU8) 3), LOC15, LOC16, 0);
			}
			LA13: ;
		}
		break;
		case ((NU8) 4):
		{
			einvalidvalue1253* e_140247;
			NimStringDesc* LOC23;
			{
				TY140177 LOC22;
				if (!(level_139293 <= ((NU8) 4))) goto LA20;
				memset((void*)LOC22, 0, sizeof(LOC22));
				logloop_139319(((NU8) 4), e_140058.kindU.S4.Msg, LOC22, 0);
			}
			LA20: ;
			e_140247 = 0;
			e_140247 = (einvalidvalue1253*) newObj((&NTI17401), sizeof(einvalidvalue1253));
			(*e_140247).Sup.Sup.Sup.m_type = (&NTI1253);
			LOC23 = 0;
			LOC23 = (*e_140247).Sup.Sup.message; (*e_140247).Sup.Sup.message = copyStringRC1(e_140058.kindU.S4.Msg);
			if (LOC23) nimGCunrefNoCycle(LOC23);
			raiseException((E_Base*)e_140247, "EInvalidValue");
		}
		break;
		}
	} LA6: ;
	npcclose(&p);
	return result;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell40090* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_43442(src);
		(*c).Refcount += 8;
	}
	LA3: ;
	{
		tcell40090* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_43442((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_45002(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(NimStringDesc*, myfindfile_140601)(NimStringDesc* filename) {
	NimStringDesc* result;
	result = 0;
	{
		NimStringDesc* LOC5;
		TY140177 LOC6;
		if (!(level_139293 <= ((NU8) 1))) goto LA3;
		LOC5 = 0;
		LOC5 = rawNewString(filename->Sup.len + 13);
appendString(LOC5, ((NimStringDesc*) &TMP166));
appendString(LOC5, filename);
appendString(LOC5, ((NimStringDesc*) &TMP167));
		memset((void*)LOC6, 0, sizeof(LOC6));
		logloop_139319(((NU8) 1), LOC5, LOC6, 0);
	}
	LA3: ;
	{
		NimStringDesc* LOC11;
		TY140177 LOC12;
		if (!(level_139293 <= ((NU8) 1))) goto LA9;
		LOC11 = 0;
		LOC11 = rawNewString(g_140017.Basedir->Sup.len + 12);
appendString(LOC11, ((NimStringDesc*) &TMP168));
appendString(LOC11, g_140017.Basedir);
appendString(LOC11, ((NimStringDesc*) &TMP167));
		memset((void*)LOC12, 0, sizeof(LOC12));
		logloop_139319(((NU8) 1), LOC11, LOC12, 0);
	}
	LA9: ;
	{
		if (!(0 < g_140017.Basedir->Sup.len)) goto LA15;
		result = HEX2F_103673(g_140017.Basedir, filename);
		{
			NIM_BOOL LOC19;
			LOC19 = 0;
			LOC19 = nosexistsFile(result);
			if (!LOC19) goto LA20;
			{
				NimStringDesc* LOC26;
				TY140177 LOC27;
				if (!(level_139293 <= ((NU8) 1))) goto LA24;
				LOC26 = 0;
				LOC26 = rawNewString(result->Sup.len + 12);
appendString(LOC26, ((NimStringDesc*) &TMP169));
appendString(LOC26, result);
appendString(LOC26, ((NimStringDesc*) &TMP167));
				memset((void*)LOC27, 0, sizeof(LOC27));
				logloop_139319(((NU8) 1), LOC26, LOC27, 0);
			}
			LA24: ;
			goto BeforeRet;
		}
		LA20: ;
	}
	LA15: ;
	{
		NIM_BOOL LOC30;
		LOC30 = 0;
		LOC30 = nosexistsFile(filename);
		if (!LOC30) goto LA31;
		result = copyString(filename);
	}
	goto LA28;
	LA31: ;
	{
		result = copyString(((NimStringDesc*) &TMP170));
	}
	LA28: ;
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, rststringtohtml_140307)(NimStringDesc* content, NimStringDesc* filename) {
	NimStringDesc* result;
	NU8 parseoptions;
	trstgenerator127012 generator;
	NIM_BOOL hastoc;
	TY89506 LOC5;
	NimStringDesc* LOC6;
	trstnode115012* rst;
	NimStringDesc* moddesc;
	ttimeinfo89403 lastmod;
	time_t LOC7;
	NimStringDesc* title;
	NimStringDesc* LOC8;
	NimStringDesc* LOC9;
	TY140664 LOC10;
	result = 0;
	parseoptions = 4;
	memset((void*)&generator, 0, sizeof(generator));
	generator.Sup.m_type = (&NTI127012);
	hastoc = 0;
	{
		if (!g_140017.Config == 0) goto LA3;
		asgnRefNoCycle((void**) &g_140017.Config, loadconfig_140020(((NimStringDesc*) &TMP155)));
	}
	LA3: ;
	memset((void*)&LOC5, 0, sizeof(LOC5));
	nossplitPath(filename, &LOC5);
	LOC6 = 0;
	LOC6 = g_140017.Basedir; g_140017.Basedir = copyStringRC1(LOC5.Field0);
	if (LOC6) nimGCunrefNoCycle(LOC6);
	initrstgenerator_127040(&generator, ((NU8) 0), g_140017.Config, filename, parseoptions, myfindfile_140601, defaultmsghandler_116803);
	rst = rstparse_122542(content, filename, 1, 1, &hastoc, parseoptions, myfindfile_140601, NIM_NIL);
	result = rawNewString(30000);
	moddesc = rawNewString(30000);
	renderrsttoout_127329(&generator, rst, &moddesc);
	LOC7 = 0;
	LOC7 = nosgetLastModificationTime(filename);
	chckNil((void*)&lastmod);
	memset((void*)&lastmod, 0, sizeof(lastmod));
	lastmod.Sup.m_type = (&NTI89403);
	getgmtime_89445(LOC7, &lastmod);
	title = copyString(generator.Meta[(((NU8) 1))- 0]);
	LOC8 = 0;
	LOC8 = nstGet(g_140017.Config, ((NimStringDesc*) &TMP668));
	LOC9 = 0;
	LOC9 = subex_135519(LOC8);
	memset((void*)LOC10, 0, sizeof(LOC10));
	LOC10[0] = copyString(((NimStringDesc*) &TMP669));
	LOC10[1] = copyString(title);
	LOC10[2] = copyString(((NimStringDesc*) &TMP670));
	LOC10[3] = format_91395(&lastmod, ((NimStringDesc*) &TMP723));
	LOC10[4] = copyString(((NimStringDesc*) &TMP724));
	LOC10[5] = format_91395(&lastmod, ((NimStringDesc*) &TMP725));
	LOC10[6] = copyString(((NimStringDesc*) &TMP726));
	LOC10[7] = copyString(moddesc);
	result = nfrmtFormatOpenArray(LOC9, LOC10, 8);
	return result;
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_12838 = (*exchandler_12838).prev;
}

static N_INLINE(E_Base*, getCurrentException)(void) {
	E_Base* result;
	result = 0;
	result = currexception_12840;
	return result;
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRefNoCycle((void**) &currexception_12840, (*currexception_12840).parent);
}

N_NIMCALL(NimStringDesc*, nimfiletohtml_140692)(NimStringDesc* filename) {
	NimStringDesc* result;
	TSafePoint TMP86;
	result = 0;
	pushSafePoint(&TMP86);
	TMP86.status = setjmp(TMP86.context);
	if (TMP86.status == 0) {
		NimStringDesc* volatile name;
		TY103885 LOC2;
		NimStringDesc* volatile titlesymbols;
		NI volatile length;
		NI64 LOC3;
		NimStringDesc* volatile source;
		NimStringDesc* LOC4;
		NimStringDesc* LOC5;
		NimStringDesc* LOC6;
		memset((void*)&LOC2, 0, sizeof(LOC2));
		nossplitFile(filename, &LOC2);
		name = LOC2.Field1;
		titlesymbols = nsuRepeatChar(name->Sup.len, 61);
		LOC3 = 0;
		LOC3 = nosgetFileSize(filename);
		length = (NI64)(1000 + ((NI) (LOC3)));
		source = rawNewString(length);
		LOC4 = 0;
		LOC4 = rawNewString(titlesymbols->Sup.len + name->Sup.len + titlesymbols->Sup.len + 28);
appendString(LOC4, titlesymbols);
appendString(LOC4, ((NimStringDesc*) &TMP95));
appendString(LOC4, name);
appendString(LOC4, ((NimStringDesc*) &TMP95));
appendString(LOC4, titlesymbols);
appendString(LOC4, ((NimStringDesc*) &TMP96));
		source = LOC4;
		LOC5 = 0;
		LOC5 = readfile_10240(filename);
		LOC6 = 0;
		LOC6 = nsuReplaceStr(LOC5, ((NimStringDesc*) &TMP95), ((NimStringDesc*) &TMP103));
		source = resizeString(source, LOC6->Sup.len + 0);
appendString(source, LOC6);
		result = rststringtohtml_140307(source, filename);
		popSafePoint();
	}
	else {
		popSafePoint();
		if (isObj(getCurrentException()->Sup.m_type, (&NTI1225))) {
			NimStringDesc* LOC9;
			TMP86.status = 0;
			LOC9 = 0;
			LOC9 = rawNewString(filename->Sup.len + 45);
appendString(LOC9, ((NimStringDesc*) &TMP727));
appendString(LOC9, filename);
appendString(LOC9, ((NimStringDesc*) &TMP728));
			result = LOC9;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI1235))) {
			NimStringDesc* LOC11;
			TMP86.status = 0;
			LOC11 = 0;
			LOC11 = rawNewString(filename->Sup.len + 48);
appendString(LOC11, ((NimStringDesc*) &TMP729));
appendString(LOC11, filename);
appendString(LOC11, ((NimStringDesc*) &TMP728));
			result = LOC11;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI1233))) {
			NimStringDesc* LOC13;
			TMP86.status = 0;
			LOC13 = 0;
			LOC13 = rawNewString(filename->Sup.len + 49);
appendString(LOC13, ((NimStringDesc*) &TMP730));
appendString(LOC13, filename);
appendString(LOC13, ((NimStringDesc*) &TMP728));
			result = LOC13;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI1257))) {
			TMP86.status = 0;
			result = copyString(((NimStringDesc*) &TMP731));
			popCurrentException();
		}
	}
	if (TMP86.status != 0) reraiseException();
	return result;
}

N_NIMCALL(NimStringDesc*, rstfiletohtml_140670)(NimStringDesc* filename) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = readfile_10240(filename);
	result = rststringtohtml_140307(LOC1, filename);
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(NimStringDesc*, getcurrentexceptionmsg_76235)(void) {
	NimStringDesc* result;
	E_Base* e;
	result = 0;
	e = getCurrentException();
	{
		if (!(e == NIM_NIL)) goto LA3;
		result = copyString(((NimStringDesc*) &TMP170));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString((*e).message);
	}
	LA1: ;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, saferstfiletohtml_140676)(NimStringDesc* filename) {
	NimStringDesc* result;
	TSafePoint TMP732;
	result = 0;
	pushSafePoint(&TMP732);
	TMP732.status = setjmp(TMP732.context);
	if (TMP732.status == 0) {
		result = rstfiletohtml_140670(filename);
		popSafePoint();
	}
	else {
		popSafePoint();
		{
			NimStringDesc* volatile content;
			TSafePoint TMP733;
			E_Base* volatile e;
			NimStringDesc* volatile msg;
			NimStringDesc* LOC9;
			NimStringDesc* LOC10;
			NimStringDesc* LOC11;
			NimStringDesc* LOC12;
			NimStringDesc* LOC13;
			TMP732.status = 0;
			content = 0;
			pushSafePoint(&TMP733);
			TMP733.status = setjmp(TMP733.context);
			if (TMP733.status == 0) {
				NimStringDesc* LOC5;
				LOC5 = 0;
				LOC5 = readfile_10240(filename);
				content = xmlencode_137271(LOC5);
				popSafePoint();
			}
			else {
				popSafePoint();
				if (isObj(getCurrentException()->Sup.m_type, (&NTI1225))) {
					NimStringDesc* LOC8;
					TMP733.status = 0;
					LOC8 = 0;
					LOC8 = rawNewString(filename->Sup.len + 18);
appendString(LOC8, ((NimStringDesc*) &TMP738));
appendString(LOC8, filename);
appendString(LOC8, ((NimStringDesc*) &TMP739));
					content = LOC8;
					popCurrentException();
				}
			}
			if (TMP733.status != 0) reraiseException();
			e = getCurrentException();
			msg = getcurrentexceptionmsg_76235();
			LOC9 = 0;
			LOC10 = 0;
			LOC10 = xmlencode_137271(filename);
			LOC11 = 0;
			LOC11 = xmlencode_137271(reprAny(e, (&NTI6416)));
			LOC12 = 0;
			LOC12 = xmlencode_137271(msg);
			LOC13 = 0;
			LOC13 = nsuReplaceStr(content, ((NimStringDesc*) &TMP95), ((NimStringDesc*) &TMP766));
			LOC9 = rawNewString(LOC10->Sup.len + LOC11->Sup.len + LOC12->Sup.len + LOC13->Sup.len + 327);
appendString(LOC9, ((NimStringDesc*) &TMP740));
appendString(LOC9, LOC10);
appendString(LOC9, ((NimStringDesc*) &TMP741));
appendString(LOC9, LOC11);
appendString(LOC9, ((NimStringDesc*) &TMP764));
appendString(LOC9, LOC12);
appendString(LOC9, ((NimStringDesc*) &TMP765));
appendString(LOC9, LOC13);
appendString(LOC9, ((NimStringDesc*) &TMP767));
			result = LOC9;
			popCurrentException();
		}
	}
	if (TMP732.status != 0) reraiseException();
	return result;
}

N_NIMCALL(NI, txt_to_rst)(NCSTRING inputfilename) {
	NI result;
	NimStringDesc* filename;
	TY103885 LOC1;
	result = 0;
	filename = cstrToNimstr(inputfilename);
	memset((void*)&LOC1, 0, sizeof(LOC1));
	nossplitFile(filename, &LOC1);
	if (eqStrings(LOC1.Field2, ((NimStringDesc*) &TMP85))) goto LA2;
	goto LA3;
	LA2: ;
	{
		asgnRefNoCycle((void**) &g_140017.Lastcconversion, nimfiletohtml_140692(filename));
	}
	goto LA4;
	LA3: ;
	{
		asgnRefNoCycle((void**) &g_140017.Lastcconversion, saferstfiletohtml_140676(filename));
	}
	LA4: ;
	result = g_140017.Lastcconversion->Sup.len;
	return result;
}

N_NIMCALL(void, get_global_html)(void* outputbuffer) {
	{
		if (!g_140017.Lastcconversion == 0) goto LA3;
		quit_77030(((NimStringDesc*) &TMP768), 1);
	}
	LA3: ;
	memcpy(outputbuffer, ((void*) (&g_140017.Lastcconversion->data[0])), g_140017.Lastcconversion->Sup.len);
}

N_NIMCALL(void, log_139121)(tlogger139024* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0) {
	{
		if (!((l) && isObj((*l).Sup.m_type, (&NTI139030)))) goto LA3;
		log_139266(((trollingfilelogger139030*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA3: ;
	{
		if (!((l) && isObj((*l).Sup.m_type, (&NTI139028)))) goto LA6;
		log_139150(((tfilelogger139028*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA6: ;
	{
		if (!((l) && isObj((*l).Sup.m_type, (&NTI139026)))) goto LA9;
		log_139124(((tconsolelogger139026*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA9: ;
	{
		if (!((l) && isObj((*l).Sup.m_type, (&NTI139024)))) goto LA12;
		log_139111(l, level, frmt, args, argsLen0);
	}
	goto LA1;
	LA12: ;
	LA1: ;
}

static N_INLINE(void, initStackBottom)(void) {
	void* volatile locals;
	locals = 0;
	locals = ((void*) (&locals));
	setStackBottom(locals);
}
void PreMain() {
	systemDatInit();
	systemInit();
	pureparseutilsDatInit();
	purestrutilsDatInit();
	puretimesDatInit();
	posixposixDatInit();
	pureosDatInit();
	purehashesDatInit();
	purestrtabsDatInit();
	docutilsrstastDatInit();
	docutilsrstDatInit();
	docutilshighliteDatInit();
	docutilsrstgenDatInit();
	purestreamsDatInit();
	purelexbaseDatInit();
	pureparsecfgDatInit();
	puresubexesDatInit();
	purecookiesDatInit();
	purecgiDatInit();
	nimloggingDatInit();
	resterDatInit();
	initStackBottom();
	pureparseutilsInit();
	purestrutilsInit();
	puretimesInit();
	posixposixInit();
	pureosInit();
	purehashesInit();
	purestrtabsInit();
	docutilsrstastInit();
	docutilsrstInit();
	docutilshighliteInit();
	docutilsrstgenInit();
	purestreamsInit();
	purelexbaseInit();
	pureparsecfgInit();
	puresubexesInit();
	purecookiesInit();
	purecgiInit();
	nimloggingInit();
}

int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMain)(void) {
	PreMain();
	resterInit();
}

N_NOINLINE(void, resterInit)(void) {
}

N_NOINLINE(void, resterDatInit)(void) {
static TNimNode TMP5[1];
NTI140312.size = sizeof(NU8);
NTI140312.kind = 19;
NTI140312.base = (&NTI116006);
NTI140312.flags = 3;
TMP5[0].len = 0; TMP5[0].kind = 0;
NTI140312.node = &TMP5[0];
}


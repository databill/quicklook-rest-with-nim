/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct tformatparser127650 tformatparser127650;
typedef struct TY127997 TY127997;
typedef struct einvalidsubex127625 einvalidsubex127625;
typedef struct einvalidvalue1053 einvalidvalue1053;
typedef struct esynch1029 esynch1029;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct tcell38448 tcell38448;
typedef struct tcellseq38464 tcellseq38464;
typedef struct tgcheap40416 tgcheap40416;
typedef struct tcellset38460 tcellset38460;
typedef struct tpagedesc38456 tpagedesc38456;
typedef struct tmemregion21810 tmemregion21810;
typedef struct tsmallchunk21038 tsmallchunk21038;
typedef struct tllchunk21804 tllchunk21804;
typedef struct tbigchunk21040 tbigchunk21040;
typedef struct tintset21015 tintset21015;
typedef struct ttrunk21011 ttrunk21011;
typedef struct tavlnode21808 tavlnode21808;
typedef struct tgcstat40414 tgcstat40414;
typedef struct tbasechunk21036 tbasechunk21036;
typedef struct tfreecell21028 tfreecell21028;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
struct tformatparser127650 {
NCSTRING F;
NI Num;
NI I;
NI Linelen;
};
struct TY127997 {
NI Field0;
NI Field1;
};
typedef N_NIMCALL_PTR(void, TY889) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY889 marker;
};
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct esynch1029 {
  E_Base Sup;
};
struct einvalidvalue1053 {
  esynch1029 Sup;
};
struct einvalidsubex127625 {
  einvalidvalue1053 Sup;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tcell38448 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq38464 {
NI Len;
NI Cap;
tcell38448** D;
};
struct tcellset38460 {
NI Counter;
NI Max;
tpagedesc38456* Head;
tpagedesc38456** Data;
};
typedef tsmallchunk21038* TY21822[512];
typedef ttrunk21011* ttrunkbuckets21013[256];
struct tintset21015 {
ttrunkbuckets21013 Data;
};
struct tmemregion21810 {
NI Minlargeobj;
NI Maxlargeobj;
TY21822 Freesmallchunks;
tllchunk21804* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk21040* Freechunkslist;
tintset21015 Chunkstarts;
tavlnode21808* Root;
tavlnode21808* Deleted;
tavlnode21808* Last;
tavlnode21808* Freeavlnodes;
};
struct tgcstat40414 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap40416 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq38464 Zct;
tcellseq38464 Decstack;
tcellset38460 Cycleroots;
tcellseq38464 Tempstack;
NI Recgclock;
tmemregion21810 Region;
tgcstat40414 Stat;
};
typedef NI TY21018[8];
struct tpagedesc38456 {
tpagedesc38456* Next;
NI Key;
TY21018 Bits;
};
struct tbasechunk21036 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk21038 {
  tbasechunk21036 Sup;
tsmallchunk21038* Next;
tsmallchunk21038* Prev;
tfreecell21028* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct tllchunk21804 {
NI Size;
NI Acc;
tllchunk21804* Next;
};
struct tbigchunk21040 {
  tbasechunk21036 Sup;
tbigchunk21040* Next;
tbigchunk21040* Prev;
NI Align;
NF Data;
};
struct ttrunk21011 {
ttrunk21011* Next;
NI Key;
TY21018 Bits;
};
typedef tavlnode21808* TY21814[2];
struct tavlnode21808 {
TY21814 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tfreecell21028 {
tfreecell21028* Next;
NI Zerofield;
};
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
N_NIMCALL(void, nfrmtAddf)(NimStringDesc** s, NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(void, scandollar_127800)(tformatparser127650* p, NimStringDesc** a, NI aLen0, NimStringDesc** s);
static N_INLINE(void, emitchar_127809)(tformatparser127650* p, NimStringDesc** x, NIM_CHAR ch);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(TY127997, scanslice_127991)(tformatparser127650* p, NimStringDesc** a, NI aLen0);
N_NOINLINE(void, raiseinvalidformat_127627)(NimStringDesc* msg);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP625)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
static N_INLINE(tcell38448*, usrtocell_41839)(void* usr);
static N_INLINE(void, rtladdzct_43402)(tcell38448* c);
N_NOINLINE(void, addzct_41815)(tcellseq38464* s, tcell38448* c);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
N_NIMCALL(NI, getformatarg_127668)(tformatparser127650* p, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NI, findnormalized_127603)(NimStringDesc* x, NimStringDesc** inarray, NI inarrayLen0);
N_NIMCALL(NI, nsuCmpIgnoreStyle)(NimStringDesc* a, NimStringDesc* b);
N_NIMCALL(NI, nsuParseInt)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
static N_INLINE(void, emitstr_127841)(tformatparser127650* p, NimStringDesc** x, NimStringDesc* y);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(void, scanbranch_127902)(tformatparser127650* p, NimStringDesc** a, NI aLen0, NimStringDesc** x, NI choice);
N_NIMCALL(void, scanquote_127860)(tformatparser127650* p, NimStringDesc** x, NIM_BOOL toadd);
static N_INLINE(void, emitstrlinear_127828)(tformatparser127650* p, NimStringDesc** x, NimStringDesc* y);
STRING_LITERAL(TMP626, "invalid format string: ", 23);
STRING_LITERAL(TMP627, "\'{\' expected", 12);
STRING_LITERAL(TMP628, "", 0);
STRING_LITERAL(TMP629, "\'#\', \'$\', number or identifier expected", 39);
STRING_LITERAL(TMP630, "index out of bounds: ", 21);
STRING_LITERAL(TMP631, "\'}\' expected", 12);
STRING_LITERAL(TMP632, "closing \"\'\" expected", 20);
STRING_LITERAL(TMP633, "closing \']\' expected", 20);
STRING_LITERAL(TMP634, "unit \'c\' (chars) or \'i\' (items) expected", 40);
extern TNimType NTI1053; /* EInvalidValue */
TNimType NTI127625; /* EInvalidSubex */
TNimType NTI127633; /* ref EInvalidSubex */
extern tgcheap40416 gch_40444;

static N_INLINE(void, emitchar_127809)(tformatparser127650* p, NimStringDesc** x, NIM_CHAR ch) {
	(*x) = addChar((*x), ch);
	{
		if (!((NU8)(ch) == (NU8)(10))) goto LA3;
		(*p).Linelen = 0;
	}	goto LA1;
	LA3: ;
	{
		(*p).Linelen += 1;
	}	LA1: ;
}N_NIMCALL(void, TMP625)(void* p, NI op) {
	einvalidsubex127625* a;
	a = (einvalidsubex127625*)p;
	nimGCvisit((void*)(*a).Sup.Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.trace, op);
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));	(*dest).Sup.len += (*src).Sup.len;
}
static N_INLINE(tcell38448*, usrtocell_41839)(void* usr) {
	tcell38448* result;
	result = 0;
	result = ((tcell38448*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell38448))))));
	return result;
}
static N_INLINE(void, rtladdzct_43402)(tcell38448* c) {
	addzct_41815(&gch_40444.Zct, c);}
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell38448* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_41839(src);
		(*c).Refcount += 8;
	}	LA3: ;
	{
		tcell38448* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_41839((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_43402(c);		}		LA11: ;
	}	LA7: ;
	(*dest) = src;
}
N_NOINLINE(void, raiseinvalidformat_127627)(NimStringDesc* msg) {
	einvalidsubex127625* e_127632;
	NimStringDesc* LOC1;
	e_127632 = 0;
	e_127632 = (einvalidsubex127625*) newObj((&NTI127633), sizeof(einvalidsubex127625));
	(*e_127632).Sup.Sup.Sup.Sup.m_type = (&NTI127625);
	LOC1 = 0;
	LOC1 = rawNewString(msg->Sup.len + 23);
appendString(LOC1, ((NimStringDesc*) &TMP626));
appendString(LOC1, msg);
	asgnRefNoCycle((void**) &(*e_127632).Sup.Sup.Sup.message, LOC1);
	raiseException((E_Base*)e_127632, "EInvalidSubex");
}
N_NIMCALL(NI, findnormalized_127603)(NimStringDesc* x, NimStringDesc** inarray, NI inarrayLen0) {
	NI result;
	NI i;
	result = 0;
	i = 0;
	while (1) {
		if (!(i < (inarrayLen0-1))) goto LA1;
		{
			NI LOC4;
			LOC4 = 0;
			LOC4 = nsuCmpIgnoreStyle(x, inarray[i]);
			if (!(LOC4 == 0)) goto LA5;
			result = i;
			goto BeforeRet;
		}		LA5: ;
		i += 2;
	} LA1: ;
	result = -1;
	goto BeforeRet;
	BeforeRet: ;	return result;
}
N_NIMCALL(NI, getformatarg_127668)(tformatparser127650* p, NimStringDesc** a, NI aLen0) {
	NI result;
	NI i;
	NCSTRING f;
	result = 0;
	i = (*p).I;
	f = (*p).F;
	switch (((NU8)(f[i]))) {
	case 35:
	{
		result = (*p).Num;
		i += 1;
		(*p).Num += 1;
	}	break;
	case 49 ... 57:
	case 45:
	{
		NI j;
		NIM_BOOL negative;
		j = 0;
		negative = ((NU8)(f[i]) == (NU8)(45));
		{
			if (!negative) goto LA5;
			i += 1;
		}		LA5: ;
		while (1) {
			if (!(((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)))) goto LA7;
			j = (NI64)((NI64)((NI64)(j * 10) + ((NI) (((NU8)(f[i]))))) - 48);
			i += 1;
		} LA7: ;
		{
			if (!!(negative)) goto LA10;
			result = (NI64)(j - 1);
		}		goto LA8;
		LA10: ;
		{
			result = (NI64)(aLen0 - j);
		}		LA8: ;
	}	break;
	case 97 ... 122:
	case 65 ... 90:
	case 128 ... 255:
	case 95:
	{
		NimStringDesc* name;
		NI LOC15;
		name = copyString(((NimStringDesc*) &TMP628));
		while (1) {
			if (!(((NU8)(f[i])) >= ((NU8)(97)) && ((NU8)(f[i])) <= ((NU8)(122)) || ((NU8)(f[i])) >= ((NU8)(65)) && ((NU8)(f[i])) <= ((NU8)(90)) || ((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)) || ((NU8)(f[i])) >= ((NU8)(128)) && ((NU8)(f[i])) <= ((NU8)(255)) || ((NU8)(f[i])) == ((NU8)(95)))) goto LA14;
			name = addChar(name, f[i]);
			i += 1;
		} LA14: ;
		LOC15 = 0;
		LOC15 = findnormalized_127603(name, a, aLen0);
		result = (NI64)(LOC15 + 1);
	}	break;
	case 36:
	{
		NI LOC17;
		i += 1;
		(*p).I = i;
		result = getformatarg_127668(p, a, aLen0);
		i = (*p).I;
		LOC17 = 0;
		LOC17 = nsuParseInt(a[result]);
		result = (NI64)(LOC17 - 1);
	}	break;
	default:
	{
		raiseinvalidformat_127627(((NimStringDesc*) &TMP629));	}	break;
	}
	{
		NimStringDesc* LOC23;
		NimStringDesc* LOC24;
		if (!((NU64)(aLen0) <= (NU64)(result))) goto LA21;
		LOC23 = 0;
		LOC24 = 0;
		LOC24 = nimIntToStr(result);
		LOC23 = rawNewString(LOC24->Sup.len + 21);
appendString(LOC23, ((NimStringDesc*) &TMP630));
appendString(LOC23, LOC24);
		raiseinvalidformat_127627(LOC23);	}	LA21: ;
	(*p).I = i;
	return result;
}
N_NIMCALL(TY127997, scanslice_127991)(tformatparser127650* p, NimStringDesc** a, NI aLen0) {
	TY127997 result;
	NIM_BOOL slice;
	NI i;
	NCSTRING f;
	memset((void*)&result, 0, sizeof(result));
	slice = NIM_FALSE;
	i = (*p).I;
	f = (*p).F;
	{
		if (!((NU8)(f[i]) == (NU8)(123))) goto LA3;
		i += 1;
	}	goto LA1;
	LA3: ;
	{
		raiseinvalidformat_127627(((NimStringDesc*) &TMP627));	}	LA1: ;
	{
		NIM_BOOL LOC8;
		LOC8 = 0;
		LOC8 = ((NU8)(f[i]) == (NU8)(46));
		if (!(LOC8)) goto LA9;
		LOC8 = ((NU8)(f[(NI64)(i + 1)]) == (NU8)(46));
		LA9: ;
		if (!LOC8) goto LA10;
		i += 2;
		slice = NIM_TRUE;
	}	goto LA6;
	LA10: ;
	{
		(*p).I = i;
		result.Field0 = getformatarg_127668(p, a, aLen0);
		i = (*p).I;
		{
			NIM_BOOL LOC15;
			LOC15 = 0;
			LOC15 = ((NU8)(f[i]) == (NU8)(46));
			if (!(LOC15)) goto LA16;
			LOC15 = ((NU8)(f[(NI64)(i + 1)]) == (NU8)(46));
			LA16: ;
			if (!LOC15) goto LA17;
			i += 2;
			slice = NIM_TRUE;
		}		LA17: ;
	}	LA6: ;
	{
		if (!slice) goto LA21;
		{
			if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA25;
			(*p).I = i;
			result.Field1 = getformatarg_127668(p, a, aLen0);
			i = (*p).I;
		}		goto LA23;
		LA25: ;
		{
			result.Field1 = (aLen0-1);
		}		LA23: ;
	}	goto LA19;
	LA21: ;
	{
		result.Field1 = result.Field0;
	}	LA19: ;
	{
		if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA31;
		raiseinvalidformat_127627(((NimStringDesc*) &TMP631));	}	LA31: ;
	i += 1;
	(*p).I = i;
	return result;
}
static N_INLINE(void, emitstr_127841)(tformatparser127650* p, NimStringDesc** x, NimStringDesc* y) {
	(*x) = resizeString((*x), y->Sup.len + 0);
appendString((*x), y);
	(*p).Linelen += y->Sup.len;
}
N_NIMCALL(void, scanquote_127860)(tformatparser127650* p, NimStringDesc** x, NIM_BOOL toadd) {
	NI i;
	NCSTRING f;
	i = (NI64)((*p).I + 1);
	f = (*p).F;
	while (1) {
		{
			if (!((NU8)(f[i]) == (NU8)(39))) goto LA4;
			i += 1;
			{
				if (!!(((NU8)(f[i]) == (NU8)(39)))) goto LA8;
				goto LA1;
			}			LA8: ;
			i += 1;
			{
				if (!toadd) goto LA12;
				emitchar_127809(p, x, 39);			}			LA12: ;
		}		goto LA2;
		LA4: ;
		{
			if (!((NU8)(f[i]) == (NU8)(0))) goto LA15;
			raiseinvalidformat_127627(((NimStringDesc*) &TMP632));		}		goto LA2;
		LA15: ;
		{
			{
				if (!toadd) goto LA20;
				emitchar_127809(p, x, f[i]);			}			LA20: ;
			i += 1;
		}		LA2: ;
	} LA1: ;
	(*p).I = i;
}
N_NIMCALL(void, scanbranch_127902)(tformatparser127650* p, NimStringDesc** a, NI aLen0, NimStringDesc** x, NI choice) {
	NI i;
	NCSTRING f;
	NI c;
	NI elsepart;
	NIM_BOOL toadd;
	i = (*p).I;
	f = (*p).F;
	c = 0;
	elsepart = i;
	toadd = (choice == 0);
	while (1) {
		switch (((NU8)(f[i]))) {
		case 93:
		{
			goto LA1;
		}		break;
		case 124:
		{
			i += 1;
			elsepart = i;
			c += 1;
			{
				if (!toadd) goto LA6;
				goto LA1;
			}			LA6: ;
			toadd = (choice == c);
		}		break;
		case 39:
		{
			(*p).I = i;
			scanquote_127860(p, x, toadd);			i = (*p).I;
		}		break;
		case 0:
		{
			raiseinvalidformat_127627(((NimStringDesc*) &TMP633));		}		break;
		default:
		{
			{
				if (!toadd) goto LA13;
				{
					if (!((NU8)(f[i]) == (NU8)(36))) goto LA17;
					i += 1;
					(*p).I = i;
					scandollar_127800(p, a, aLen0, x);					i = (*p).I;
				}				goto LA15;
				LA17: ;
				{
					emitchar_127809(p, x, f[i]);					i += 1;
				}				LA15: ;
			}			goto LA11;
			LA13: ;
			{
				i += 1;
			}			LA11: ;
		}		break;
		}
	} LA1: ;
	{
		NIM_BOOL LOC23;
		NI last;
		LOC23 = 0;
		LOC23 = !(toadd);
		if (!(LOC23)) goto LA24;
		LOC23 = (0 <= choice);
		LA24: ;
		if (!LOC23) goto LA25;
		last = i;
		i = elsepart;
		while (1) {
			switch (((NU8)(f[i]))) {
			case 124:
			case 93:
			{
				goto LA27;
			}			break;
			case 39:
			{
				(*p).I = i;
				scanquote_127860(p, x, NIM_TRUE);				i = (*p).I;
			}			break;
			case 36:
			{
				i += 1;
				(*p).I = i;
				scandollar_127800(p, a, aLen0, x);				i = (*p).I;
			}			break;
			default:
			{
				emitchar_127809(p, x, f[i]);				i += 1;
			}			break;
			}
		} LA27: ;
		i = last;
	}	LA25: ;
	(*p).I = (NI64)(i + 1);
}
static N_INLINE(void, emitstrlinear_127828)(tformatparser127650* p, NimStringDesc** x, NimStringDesc* y) {
	NIM_CHAR ch_127835;
	NI i_127837;
	ch_127835 = 0;
	i_127837 = 0;
	while (1) {
		if (!(i_127837 < y->Sup.len)) goto LA1;
		ch_127835 = y->data[i_127837];
		emitchar_127809(p, x, ch_127835);		i_127837 += 1;
	} LA1: ;
}
N_NIMCALL(void, scandollar_127800)(tformatparser127650* p, NimStringDesc** a, NI aLen0, NimStringDesc** s) {
	NI i;
	NCSTRING f;
	i = (*p).I;
	f = (*p).F;
	switch (((NU8)(f[i]))) {
	case 36:
	{
		emitchar_127809(p, s, 36);		i += 1;
	}	break;
	case 123:
	{
		TY127997 LOC3;
		NI x;
		NI y;
		NI j_128077;
		NI res_128276;
		(*p).I = i;
		LOC3 = scanslice_127991(p, a, aLen0);
		x = LOC3.Field0;
		y = LOC3.Field1;
		i = (*p).I;
		j_128077 = 0;
		res_128276 = x;
		while (1) {
			if (!(res_128276 <= y)) goto LA4;
			j_128077 = res_128276;
			emitstr_127841(p, s, a[j_128077]);			res_128276 += 1;
		} LA4: ;
	}	break;
	case 91:
	{
		NI start;
		NI x;
		NI last;
		NI choice;
		i += 1;
		start = i;
		(*p).I = i;
		scanbranch_127902(p, a, aLen0, s, -1);		i = (*p).I;
		x = 0;
		{
			if (!((NU8)(f[i]) == (NU8)(123))) goto LA8;
			i += 1;
			(*p).I = i;
			x = getformatarg_127668(p, a, aLen0);
			i = (*p).I;
			{
				if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA12;
				raiseinvalidformat_127627(((NimStringDesc*) &TMP631));			}			LA12: ;
			i += 1;
		}		goto LA6;
		LA8: ;
		{
			(*p).I = i;
			x = getformatarg_127668(p, a, aLen0);
			i = (*p).I;
		}		LA6: ;
		last = i;
		choice = nsuParseInt(a[x]);
		i = start;
		(*p).I = i;
		scanbranch_127902(p, a, aLen0, s, choice);		i = (*p).I;
		i = last;
	}	break;
	case 39:
	{
		NimStringDesc* sep;
		NI oldlinelen_128114;
		sep = copyString(((NimStringDesc*) &TMP628));
		oldlinelen_128114 = (*p).Linelen;
		(*p).I = i;
		scanquote_127860(p, &sep, NIM_TRUE);		i = (*p).I;
		(*p).Linelen = oldlinelen_128114;
		{
			TY127997 LOC20;
			NI x;
			NI y;
			NI l;
			NI j_128138;
			NI res_128280;
			if (!((NU8)(f[i]) == (NU8)(126))) goto LA18;
			i += 1;
			(*p).I = i;
			LOC20 = scanslice_127991(p, a, aLen0);
			x = LOC20.Field0;
			y = LOC20.Field1;
			i = (*p).I;
			l = 0;
			j_128138 = 0;
			res_128280 = x;
			while (1) {
				if (!(res_128280 <= y)) goto LA21;
				j_128138 = res_128280;
				l += a[j_128138]->Sup.len;
				res_128280 += 1;
			} LA21: ;
			{
				NI j_128159;
				NI res_128283;
				if (!(0 < l)) goto LA24;
				emitstrlinear_127828(p, s, sep);				j_128159 = 0;
				res_128283 = x;
				while (1) {
					if (!(res_128283 <= y)) goto LA26;
					j_128159 = res_128283;
					emitstr_127841(p, s, a[j_128159]);					res_128283 += 1;
				} LA26: ;
			}			LA24: ;
		}		goto LA16;
		LA18: ;
		{
			{
				TY127997 LOC57;
				NI x;
				NI y;
				NI j_128273;
				NI HEX3Atmp_128293;
				NI res_128295;
				{
					NI maxlen;
					NimStringDesc* indent;
					maxlen = 0;
					switch (((NU8)(f[i]))) {
					case 48 ... 57:
					{
						while (1) {
							if (!(((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)))) goto LA31;
							maxlen = (NI64)((NI64)((NI64)(maxlen * 10) + ((NI) (((NU8)(f[i]))))) - 48);
							i += 1;
						} LA31: ;
					}					break;
					case 36:
					{
						(*p).I = i;
						maxlen = getformatarg_127668(p, a, aLen0);
						i = (*p).I;
					}					break;
					default:
					{
						goto LA29;
					}					break;
					}
					indent = copyString(((NimStringDesc*) &TMP628));
					switch (((NU8)(f[i]))) {
					case 105:
					{
						NI oldlinelen_128209;
						TY127997 LOC35;
						NI x;
						NI y;
						NI items;
						NI j_128224;
						NI HEX3Atmp_128285;
						NI res_128287;
						i += 1;
						oldlinelen_128209 = (*p).Linelen;
						(*p).I = i;
						scanquote_127860(p, &indent, NIM_TRUE);						i = (*p).I;
						(*p).Linelen = oldlinelen_128209;
						(*p).I = i;
						LOC35 = scanslice_127991(p, a, aLen0);
						x = LOC35.Field0;
						y = LOC35.Field1;
						i = (*p).I;
						{
							if (!(maxlen < 1)) goto LA38;
							emitstrlinear_127828(p, s, indent);						}						LA38: ;
						items = 1;
						emitstr_127841(p, s, a[x]);						j_128224 = 0;
						HEX3Atmp_128285 = 0;
						HEX3Atmp_128285 = (NI64)(x + 1);
						res_128287 = HEX3Atmp_128285;
						while (1) {
							if (!(res_128287 <= y)) goto LA40;
							j_128224 = res_128287;
							emitstr_127841(p, s, sep);							{
								if (!(maxlen <= items)) goto LA43;
								emitstrlinear_127828(p, s, indent);								items = 0;
							}							LA43: ;
							emitstr_127841(p, s, a[j_128224]);							items += 1;
							res_128287 += 1;
						} LA40: ;
					}					break;
					case 99:
					{
						NI oldlinelen_128246;
						TY127997 LOC46;
						NI x;
						NI y;
						NI j_128260;
						NI HEX3Atmp_128289;
						NI res_128291;
						i += 1;
						oldlinelen_128246 = (*p).Linelen;
						(*p).I = i;
						scanquote_127860(p, &indent, NIM_TRUE);						i = (*p).I;
						(*p).Linelen = oldlinelen_128246;
						(*p).I = i;
						LOC46 = scanslice_127991(p, a, aLen0);
						x = LOC46.Field0;
						y = LOC46.Field1;
						i = (*p).I;
						{
							if (!(maxlen < (NI64)((*p).Linelen + a[x]->Sup.len))) goto LA49;
							emitstrlinear_127828(p, s, indent);						}						LA49: ;
						emitstr_127841(p, s, a[x]);						j_128260 = 0;
						HEX3Atmp_128289 = 0;
						HEX3Atmp_128289 = (NI64)(x + 1);
						res_128291 = HEX3Atmp_128289;
						while (1) {
							if (!(res_128291 <= y)) goto LA51;
							j_128260 = res_128291;
							emitstr_127841(p, s, sep);							{
								if (!(maxlen < (NI64)((*p).Linelen + a[j_128260]->Sup.len))) goto LA54;
								emitstrlinear_127828(p, s, indent);							}							LA54: ;
							emitstr_127841(p, s, a[j_128260]);							res_128291 += 1;
						} LA51: ;
					}					break;
					default:
					{
						raiseinvalidformat_127627(((NimStringDesc*) &TMP634));					}					break;
					}
					goto LA28;
				} LA29: ;
				(*p).I = i;
				LOC57 = scanslice_127991(p, a, aLen0);
				x = LOC57.Field0;
				y = LOC57.Field1;
				i = (*p).I;
				emitstr_127841(p, s, a[x]);				j_128273 = 0;
				HEX3Atmp_128293 = 0;
				HEX3Atmp_128293 = (NI64)(x + 1);
				res_128295 = HEX3Atmp_128293;
				while (1) {
					if (!(res_128295 <= y)) goto LA58;
					j_128273 = res_128295;
					emitstr_127841(p, s, sep);					emitstr_127841(p, s, a[j_128273]);					res_128295 += 1;
				} LA58: ;
			} LA28: ;
		}		LA16: ;
	}	break;
	default:
	{
		NI x;
		(*p).I = i;
		x = getformatarg_127668(p, a, aLen0);
		i = (*p).I;
		emitstr_127841(p, s, a[x]);	}	break;
	}
	(*p).I = i;
}
N_NIMCALL(void, nfrmtAddf)(NimStringDesc** s, NimStringDesc* formatstr, NimStringDesc** a, NI aLen0) {
	tformatparser127650 p;
	NI i;
	memset((void*)&p, 0, sizeof(p));
	p.F = formatstr->data;
	i = 0;
	while (1) {
		if (!(i < formatstr->Sup.len)) goto LA1;
		{
			if (!((NU8)(p.F[i]) == (NU8)(36))) goto LA4;
			i += 1;
			p.I = i;
			scandollar_127800(&p, a, aLen0, s);			i = p.I;
		}		goto LA2;
		LA4: ;
		{
			emitchar_127809(&p, s, p.F[i]);			i += 1;
		}		LA2: ;
	} LA1: ;
}
N_NIMCALL(NimStringDesc*, nfrmtFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0) {
	NimStringDesc* result;
	result = 0;
	result = rawNewString((NI64)(formatstr->Sup.len + (NI)((NU64)(aLen0) << (NU64)(4))));
	nfrmtAddf(&result, formatstr, a, aLen0);	return result;
}
N_NIMCALL(NimStringDesc*, subex_128311)(NimStringDesc* s) {
	NimStringDesc* result;
	result = 0;
	result = copyString(s);
	return result;
}N_NOINLINE(void, puresubexesInit)(void) {
}

N_NOINLINE(void, puresubexesDatInit)(void) {
static TNimNode TMP36[1];
NTI127625.size = sizeof(einvalidsubex127625);
NTI127625.kind = 17;
NTI127625.base = (&NTI1053);
NTI127625.flags = 2;
TMP36[0].len = 0; TMP36[0].kind = 2;
NTI127625.node = &TMP36[0];
NTI127633.size = sizeof(einvalidsubex127625*);
NTI127633.kind = 22;
NTI127633.base = (&NTI127625);
NTI127633.flags = 2;
NTI127633.marker = TMP625;
}


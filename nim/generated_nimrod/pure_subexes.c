/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct tformatparser134660 tformatparser134660;
typedef struct TY135119 TY135119;
typedef struct einvalidsubex134631 einvalidsubex134631;
typedef struct einvalidvalue1253 einvalidvalue1253;
typedef struct esynch1229 esynch1229;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct tcell40090 tcell40090;
typedef struct tcellseq40106 tcellseq40106;
typedef struct tgcheap42016 tgcheap42016;
typedef struct tcellset40102 tcellset40102;
typedef struct tpagedesc40098 tpagedesc40098;
typedef struct tmemregion23010 tmemregion23010;
typedef struct tsmallchunk22238 tsmallchunk22238;
typedef struct tllchunk23004 tllchunk23004;
typedef struct tbigchunk22240 tbigchunk22240;
typedef struct tintset22215 tintset22215;
typedef struct ttrunk22211 ttrunk22211;
typedef struct tavlnode23008 tavlnode23008;
typedef struct tgcstat42014 tgcstat42014;
typedef struct tbasechunk22236 tbasechunk22236;
typedef struct tfreecell22228 tfreecell22228;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY613[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY613 data;
};
struct tformatparser134660 {
NCSTRING F;
NI Num;
NI I;
NI Linelen;
};
struct TY135119 {
NI Field0;
NI Field1;
};
typedef N_NIMCALL_PTR(void, TY1089) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY1089 marker;
};
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct esynch1229 {
  E_Base Sup;
};
struct einvalidvalue1253 {
  esynch1229 Sup;
};
struct einvalidsubex134631 {
  einvalidvalue1253 Sup;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tcell40090 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq40106 {
NI Len;
NI Cap;
tcell40090** D;
};
struct tcellset40102 {
NI Counter;
NI Max;
tpagedesc40098* Head;
tpagedesc40098** Data;
};
typedef tsmallchunk22238* TY23022[512];
typedef ttrunk22211* ttrunkbuckets22213[256];
struct tintset22215 {
ttrunkbuckets22213 Data;
};
struct tmemregion23010 {
NI Minlargeobj;
NI Maxlargeobj;
TY23022 Freesmallchunks;
tllchunk23004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk22240* Freechunkslist;
tintset22215 Chunkstarts;
tavlnode23008* Root;
tavlnode23008* Deleted;
tavlnode23008* Last;
tavlnode23008* Freeavlnodes;
};
struct tgcstat42014 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap42016 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq40106 Zct;
tcellseq40106 Decstack;
tcellset40102 Cycleroots;
tcellseq40106 Tempstack;
NI Recgclock;
tmemregion23010 Region;
tgcstat42014 Stat;
};
typedef NI TY22218[8];
struct tpagedesc40098 {
tpagedesc40098* Next;
NI Key;
TY22218 Bits;
};
struct tbasechunk22236 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk22238 {
  tbasechunk22236 Sup;
tsmallchunk22238* Next;
tsmallchunk22238* Prev;
tfreecell22228* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct tllchunk23004 {
NI Size;
NI Acc;
tllchunk23004* Next;
};
struct tbigchunk22240 {
  tbasechunk22236 Sup;
tbigchunk22240* Next;
tbigchunk22240* Prev;
NI Align;
NF Data;
};
struct ttrunk22211 {
ttrunk22211* Next;
NI Key;
TY22218 Bits;
};
typedef tavlnode23008* TY23014[2];
struct tavlnode23008 {
TY23014 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tfreecell22228 {
tfreecell22228* Next;
NI Zerofield;
};
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
N_NIMCALL(void, nfrmtAddf)(NimStringDesc** s, NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(void, scandollar_134850)(tformatparser134660* p, NimStringDesc** a, NI aLen0, NimStringDesc** s);
static N_INLINE(void, emitchar_134859)(tformatparser134660* p, NimStringDesc** x, NIM_CHAR ch);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(TY135119, scanslice_135113)(tformatparser134660* p, NimStringDesc** a, NI aLen0);
N_NOINLINE(void, raiseinvalidformat_134633)(NimStringDesc* msg);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP658)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
static N_INLINE(tcell40090*, usrtocell_43442)(void* usr);
static N_INLINE(void, rtladdzct_45002)(tcell40090* c);
N_NOINLINE(void, addzct_43418)(tcellseq40106* s, tcell40090* c);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
N_NIMCALL(NI, getformatarg_134678)(tformatparser134660* p, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NI, findnormalized_134603)(NimStringDesc* x, NimStringDesc** inarray, NI inarrayLen0);
N_NIMCALL(NI, nsuCmpIgnoreStyle)(NimStringDesc* a, NimStringDesc* b);
N_NIMCALL(NI, nsuParseInt)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
static N_INLINE(void, emitstr_134897)(tformatparser134660* p, NimStringDesc** x, NimStringDesc* y);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(void, scanbranch_134982)(tformatparser134660* p, NimStringDesc** a, NI aLen0, NimStringDesc** x, NI choice);
N_NIMCALL(void, scanquote_134922)(tformatparser134660* p, NimStringDesc** x, NIM_BOOL toadd);
static N_INLINE(void, emitstrlinear_134884)(tformatparser134660* p, NimStringDesc** x, NimStringDesc* y);
STRING_LITERAL(TMP659, "invalid format string: ", 23);
STRING_LITERAL(TMP660, "\'{\' expected", 12);
STRING_LITERAL(TMP661, "", 0);
STRING_LITERAL(TMP662, "\'#\', \'$\', number or identifier expected", 39);
STRING_LITERAL(TMP663, "index out of bounds: ", 21);
STRING_LITERAL(TMP664, "\'}\' expected", 12);
STRING_LITERAL(TMP665, "closing \"\'\" expected", 20);
STRING_LITERAL(TMP666, "closing \']\' expected", 20);
STRING_LITERAL(TMP667, "unit \'c\' (chars) or \'i\' (items) expected", 40);
extern TNimType NTI1253; /* EInvalidValue */
TNimType NTI134631; /* EInvalidSubex */
TNimType NTI134639; /* ref EInvalidSubex */
extern tgcheap42016 gch_42044;

static N_INLINE(void, emitchar_134859)(tformatparser134660* p, NimStringDesc** x, NIM_CHAR ch) {
	(*x) = addChar((*x), ch);
	{
		if (!((NU8)(ch) == (NU8)(10))) goto LA3;
		(*p).Linelen = 0;
	}
	goto LA1;
	LA3: ;
	{
		(*p).Linelen += 1;
	}
	LA1: ;
}
N_NIMCALL(void, TMP658)(void* p, NI op) {
	einvalidsubex134631* a;
	a = (einvalidsubex134631*)p;
	nimGCvisit((void*)(*a).Sup.Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.trace, op);
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(tcell40090*, usrtocell_43442)(void* usr) {
	tcell40090* result;
	result = 0;
	result = ((tcell40090*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell40090))))));
	return result;
}

static N_INLINE(void, rtladdzct_45002)(tcell40090* c) {
	addzct_43418(&gch_42044.Zct, c);
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell40090* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_43442(src);
		(*c).Refcount += 8;
	}
	LA3: ;
	{
		tcell40090* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_43442((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_45002(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NOINLINE(void, raiseinvalidformat_134633)(NimStringDesc* msg) {
	einvalidsubex134631* e_134638;
	NimStringDesc* LOC1;
	e_134638 = 0;
	e_134638 = (einvalidsubex134631*) newObj((&NTI134639), sizeof(einvalidsubex134631));
	(*e_134638).Sup.Sup.Sup.Sup.m_type = (&NTI134631);
	LOC1 = 0;
	LOC1 = rawNewString(msg->Sup.len + 23);
appendString(LOC1, ((NimStringDesc*) &TMP659));
appendString(LOC1, msg);
	asgnRefNoCycle((void**) &(*e_134638).Sup.Sup.Sup.message, LOC1);
	raiseException((E_Base*)e_134638, "EInvalidSubex");
}

N_NIMCALL(NI, findnormalized_134603)(NimStringDesc* x, NimStringDesc** inarray, NI inarrayLen0) {
	NI result;
	NI i;
	result = 0;
	i = 0;
	while (1) {
		if (!(i < (inarrayLen0-1))) goto LA1;
		{
			NI LOC4;
			LOC4 = 0;
			LOC4 = nsuCmpIgnoreStyle(x, inarray[i]);
			if (!(LOC4 == 0)) goto LA5;
			result = i;
			goto BeforeRet;
		}
		LA5: ;
		i += 2;
	} LA1: ;
	result = -1;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

N_NIMCALL(NI, getformatarg_134678)(tformatparser134660* p, NimStringDesc** a, NI aLen0) {
	NI result;
	NI i;
	NCSTRING f;
	result = 0;
	i = (*p).I;
	f = (*p).F;
	switch (((NU8)(f[i]))) {
	case 35:
	{
		result = (*p).Num;
		i += 1;
		(*p).Num += 1;
	}
	break;
	case 49 ... 57:
	case 45:
	{
		NI j;
		NIM_BOOL negative;
		j = 0;
		negative = ((NU8)(f[i]) == (NU8)(45));
		{
			if (!negative) goto LA5;
			i += 1;
		}
		LA5: ;
		while (1) {
			if (!(((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)))) goto LA7;
			j = (NI64)((NI64)((NI64)(j * 10) + ((NI) (((NU8)(f[i]))))) - 48);
			i += 1;
		} LA7: ;
		{
			if (!!(negative)) goto LA10;
			result = (NI64)(j - 1);
		}
		goto LA8;
		LA10: ;
		{
			result = (NI64)(aLen0 - j);
		}
		LA8: ;
	}
	break;
	case 97 ... 122:
	case 65 ... 90:
	case 128 ... 255:
	case 95:
	{
		NimStringDesc* name;
		NI LOC15;
		name = copyString(((NimStringDesc*) &TMP661));
		while (1) {
			if (!(((NU8)(f[i])) >= ((NU8)(97)) && ((NU8)(f[i])) <= ((NU8)(122)) || ((NU8)(f[i])) >= ((NU8)(65)) && ((NU8)(f[i])) <= ((NU8)(90)) || ((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)) || ((NU8)(f[i])) >= ((NU8)(128)) && ((NU8)(f[i])) <= ((NU8)(255)) || ((NU8)(f[i])) == ((NU8)(95)))) goto LA14;
			name = addChar(name, f[i]);
			i += 1;
		} LA14: ;
		LOC15 = 0;
		LOC15 = findnormalized_134603(name, a, aLen0);
		result = (NI64)(LOC15 + 1);
	}
	break;
	case 36:
	{
		NI LOC17;
		i += 1;
		(*p).I = i;
		result = getformatarg_134678(p, a, aLen0);
		i = (*p).I;
		LOC17 = 0;
		LOC17 = nsuParseInt(a[result]);
		result = (NI64)(LOC17 - 1);
	}
	break;
	default:
	{
		raiseinvalidformat_134633(((NimStringDesc*) &TMP662));
	}
	break;
	}
	{
		NimStringDesc* LOC23;
		NimStringDesc* LOC24;
		if (!((NU64)(aLen0) <= (NU64)(result))) goto LA21;
		LOC23 = 0;
		LOC24 = 0;
		LOC24 = nimIntToStr(result);
		LOC23 = rawNewString(LOC24->Sup.len + 21);
appendString(LOC23, ((NimStringDesc*) &TMP663));
appendString(LOC23, LOC24);
		raiseinvalidformat_134633(LOC23);
	}
	LA21: ;
	(*p).I = i;
	return result;
}

N_NIMCALL(TY135119, scanslice_135113)(tformatparser134660* p, NimStringDesc** a, NI aLen0) {
	TY135119 result;
	NIM_BOOL slice;
	NI i;
	NCSTRING f;
	memset((void*)&result, 0, sizeof(result));
	slice = NIM_FALSE;
	i = (*p).I;
	f = (*p).F;
	{
		if (!((NU8)(f[i]) == (NU8)(123))) goto LA3;
		i += 1;
	}
	goto LA1;
	LA3: ;
	{
		raiseinvalidformat_134633(((NimStringDesc*) &TMP660));
	}
	LA1: ;
	{
		NIM_BOOL LOC8;
		LOC8 = 0;
		LOC8 = ((NU8)(f[i]) == (NU8)(46));
		if (!(LOC8)) goto LA9;
		LOC8 = ((NU8)(f[(NI64)(i + 1)]) == (NU8)(46));
		LA9: ;
		if (!LOC8) goto LA10;
		i += 2;
		slice = NIM_TRUE;
	}
	goto LA6;
	LA10: ;
	{
		(*p).I = i;
		result.Field0 = getformatarg_134678(p, a, aLen0);
		i = (*p).I;
		{
			NIM_BOOL LOC15;
			LOC15 = 0;
			LOC15 = ((NU8)(f[i]) == (NU8)(46));
			if (!(LOC15)) goto LA16;
			LOC15 = ((NU8)(f[(NI64)(i + 1)]) == (NU8)(46));
			LA16: ;
			if (!LOC15) goto LA17;
			i += 2;
			slice = NIM_TRUE;
		}
		LA17: ;
	}
	LA6: ;
	{
		if (!slice) goto LA21;
		{
			if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA25;
			(*p).I = i;
			result.Field1 = getformatarg_134678(p, a, aLen0);
			i = (*p).I;
		}
		goto LA23;
		LA25: ;
		{
			result.Field1 = (aLen0-1);
		}
		LA23: ;
	}
	goto LA19;
	LA21: ;
	{
		result.Field1 = result.Field0;
	}
	LA19: ;
	{
		if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA31;
		raiseinvalidformat_134633(((NimStringDesc*) &TMP664));
	}
	LA31: ;
	i += 1;
	(*p).I = i;
	return result;
}

static N_INLINE(void, emitstr_134897)(tformatparser134660* p, NimStringDesc** x, NimStringDesc* y) {
	(*x) = resizeString((*x), y->Sup.len + 0);
appendString((*x), y);
	(*p).Linelen += y->Sup.len;
}

N_NIMCALL(void, scanquote_134922)(tformatparser134660* p, NimStringDesc** x, NIM_BOOL toadd) {
	NI i;
	NCSTRING f;
	i = (NI64)((*p).I + 1);
	f = (*p).F;
	while (1) {
		{
			if (!((NU8)(f[i]) == (NU8)(39))) goto LA4;
			i += 1;
			{
				if (!!(((NU8)(f[i]) == (NU8)(39)))) goto LA8;
				goto LA1;
			}
			LA8: ;
			i += 1;
			{
				if (!toadd) goto LA12;
				emitchar_134859(p, x, 39);
			}
			LA12: ;
		}
		goto LA2;
		LA4: ;
		{
			if (!((NU8)(f[i]) == (NU8)(0))) goto LA15;
			raiseinvalidformat_134633(((NimStringDesc*) &TMP665));
		}
		goto LA2;
		LA15: ;
		{
			{
				if (!toadd) goto LA20;
				emitchar_134859(p, x, f[i]);
			}
			LA20: ;
			i += 1;
		}
		LA2: ;
	} LA1: ;
	(*p).I = i;
}

N_NIMCALL(void, scanbranch_134982)(tformatparser134660* p, NimStringDesc** a, NI aLen0, NimStringDesc** x, NI choice) {
	NI i;
	NCSTRING f;
	NI c;
	NI elsepart;
	NIM_BOOL toadd;
	i = (*p).I;
	f = (*p).F;
	c = 0;
	elsepart = i;
	toadd = (choice == 0);
	while (1) {
		switch (((NU8)(f[i]))) {
		case 93:
		{
			goto LA1;
		}
		break;
		case 124:
		{
			i += 1;
			elsepart = i;
			c += 1;
			{
				if (!toadd) goto LA6;
				goto LA1;
			}
			LA6: ;
			toadd = (choice == c);
		}
		break;
		case 39:
		{
			(*p).I = i;
			scanquote_134922(p, x, toadd);
			i = (*p).I;
		}
		break;
		case 0:
		{
			raiseinvalidformat_134633(((NimStringDesc*) &TMP666));
		}
		break;
		default:
		{
			{
				if (!toadd) goto LA13;
				{
					if (!((NU8)(f[i]) == (NU8)(36))) goto LA17;
					i += 1;
					(*p).I = i;
					scandollar_134850(p, a, aLen0, x);
					i = (*p).I;
				}
				goto LA15;
				LA17: ;
				{
					emitchar_134859(p, x, f[i]);
					i += 1;
				}
				LA15: ;
			}
			goto LA11;
			LA13: ;
			{
				i += 1;
			}
			LA11: ;
		}
		break;
		}
	} LA1: ;
	{
		NIM_BOOL LOC23;
		NI last;
		LOC23 = 0;
		LOC23 = !(toadd);
		if (!(LOC23)) goto LA24;
		LOC23 = (0 <= choice);
		LA24: ;
		if (!LOC23) goto LA25;
		last = i;
		i = elsepart;
		while (1) {
			switch (((NU8)(f[i]))) {
			case 124:
			case 93:
			{
				goto LA27;
			}
			break;
			case 39:
			{
				(*p).I = i;
				scanquote_134922(p, x, NIM_TRUE);
				i = (*p).I;
			}
			break;
			case 36:
			{
				i += 1;
				(*p).I = i;
				scandollar_134850(p, a, aLen0, x);
				i = (*p).I;
			}
			break;
			default:
			{
				emitchar_134859(p, x, f[i]);
				i += 1;
			}
			break;
			}
		} LA27: ;
		i = last;
	}
	LA25: ;
	(*p).I = (NI64)(i + 1);
}

static N_INLINE(void, emitstrlinear_134884)(tformatparser134660* p, NimStringDesc** x, NimStringDesc* y) {
	NIM_CHAR ch_134891;
	NI i_134893;
	ch_134891 = 0;
	i_134893 = 0;
	while (1) {
		if (!(i_134893 < y->Sup.len)) goto LA1;
		ch_134891 = y->data[i_134893];
		emitchar_134859(p, x, ch_134891);
		i_134893 += 1;
	} LA1: ;
}

N_NIMCALL(void, scandollar_134850)(tformatparser134660* p, NimStringDesc** a, NI aLen0, NimStringDesc** s) {
	NI i;
	NCSTRING f;
	i = (*p).I;
	f = (*p).F;
	switch (((NU8)(f[i]))) {
	case 36:
	{
		emitchar_134859(p, s, 36);
		i += 1;
	}
	break;
	case 123:
	{
		TY135119 LOC3;
		NI x;
		NI y;
		NI j_135229;
		NI res_135484;
		(*p).I = i;
		LOC3 = scanslice_135113(p, a, aLen0);
		x = LOC3.Field0;
		y = LOC3.Field1;
		i = (*p).I;
		j_135229 = 0;
		res_135484 = x;
		while (1) {
			if (!(res_135484 <= y)) goto LA4;
			j_135229 = res_135484;
			emitstr_134897(p, s, a[j_135229]);
			res_135484 += 1;
		} LA4: ;
	}
	break;
	case 91:
	{
		NI start;
		NI x;
		NI last;
		NI choice;
		i += 1;
		start = i;
		(*p).I = i;
		scanbranch_134982(p, a, aLen0, s, -1);
		i = (*p).I;
		x = 0;
		{
			if (!((NU8)(f[i]) == (NU8)(123))) goto LA8;
			i += 1;
			(*p).I = i;
			x = getformatarg_134678(p, a, aLen0);
			i = (*p).I;
			{
				if (!!(((NU8)(f[i]) == (NU8)(125)))) goto LA12;
				raiseinvalidformat_134633(((NimStringDesc*) &TMP664));
			}
			LA12: ;
			i += 1;
		}
		goto LA6;
		LA8: ;
		{
			(*p).I = i;
			x = getformatarg_134678(p, a, aLen0);
			i = (*p).I;
		}
		LA6: ;
		last = i;
		choice = nsuParseInt(a[x]);
		i = start;
		(*p).I = i;
		scanbranch_134982(p, a, aLen0, s, choice);
		i = (*p).I;
		i = last;
	}
	break;
	case 39:
	{
		NimStringDesc* sep;
		NI oldlinelen_135284;
		sep = copyString(((NimStringDesc*) &TMP661));
		oldlinelen_135284 = (*p).Linelen;
		(*p).I = i;
		scanquote_134922(p, &sep, NIM_TRUE);
		i = (*p).I;
		(*p).Linelen = oldlinelen_135284;
		{
			TY135119 LOC20;
			NI x;
			NI y;
			NI l;
			NI j_135314;
			NI res_135488;
			if (!((NU8)(f[i]) == (NU8)(126))) goto LA18;
			i += 1;
			(*p).I = i;
			LOC20 = scanslice_135113(p, a, aLen0);
			x = LOC20.Field0;
			y = LOC20.Field1;
			i = (*p).I;
			l = 0;
			j_135314 = 0;
			res_135488 = x;
			while (1) {
				if (!(res_135488 <= y)) goto LA21;
				j_135314 = res_135488;
				l += a[j_135314]->Sup.len;
				res_135488 += 1;
			} LA21: ;
			{
				NI j_135341;
				NI res_135491;
				if (!(0 < l)) goto LA24;
				emitstrlinear_134884(p, s, sep);
				j_135341 = 0;
				res_135491 = x;
				while (1) {
					if (!(res_135491 <= y)) goto LA26;
					j_135341 = res_135491;
					emitstr_134897(p, s, a[j_135341]);
					res_135491 += 1;
				} LA26: ;
			}
			LA24: ;
		}
		goto LA16;
		LA18: ;
		{
			{
				TY135119 LOC57;
				NI x;
				NI y;
				NI j_135481;
				NI HEX3Atmp_135501;
				NI res_135503;
				{
					NI maxlen;
					NimStringDesc* indent;
					maxlen = 0;
					switch (((NU8)(f[i]))) {
					case 48 ... 57:
					{
						while (1) {
							if (!(((NU8)(f[i])) >= ((NU8)(48)) && ((NU8)(f[i])) <= ((NU8)(57)))) goto LA31;
							maxlen = (NI64)((NI64)((NI64)(maxlen * 10) + ((NI) (((NU8)(f[i]))))) - 48);
							i += 1;
						} LA31: ;
					}
					break;
					case 36:
					{
						(*p).I = i;
						maxlen = getformatarg_134678(p, a, aLen0);
						i = (*p).I;
					}
					break;
					default:
					{
						goto LA29;
					}
					break;
					}
					indent = copyString(((NimStringDesc*) &TMP661));
					switch (((NU8)(f[i]))) {
					case 105:
					{
						NI oldlinelen_135405;
						TY135119 LOC35;
						NI x;
						NI y;
						NI items;
						NI j_135420;
						NI HEX3Atmp_135493;
						NI res_135495;
						i += 1;
						oldlinelen_135405 = (*p).Linelen;
						(*p).I = i;
						scanquote_134922(p, &indent, NIM_TRUE);
						i = (*p).I;
						(*p).Linelen = oldlinelen_135405;
						(*p).I = i;
						LOC35 = scanslice_135113(p, a, aLen0);
						x = LOC35.Field0;
						y = LOC35.Field1;
						i = (*p).I;
						{
							if (!(maxlen < 1)) goto LA38;
							emitstrlinear_134884(p, s, indent);
						}
						LA38: ;
						items = 1;
						emitstr_134897(p, s, a[x]);
						j_135420 = 0;
						HEX3Atmp_135493 = 0;
						HEX3Atmp_135493 = (NI64)(x + 1);
						res_135495 = HEX3Atmp_135493;
						while (1) {
							if (!(res_135495 <= y)) goto LA40;
							j_135420 = res_135495;
							emitstr_134897(p, s, sep);
							{
								if (!(maxlen <= items)) goto LA43;
								emitstrlinear_134884(p, s, indent);
								items = 0;
							}
							LA43: ;
							emitstr_134897(p, s, a[j_135420]);
							items += 1;
							res_135495 += 1;
						} LA40: ;
					}
					break;
					case 99:
					{
						NI oldlinelen_135454;
						TY135119 LOC46;
						NI x;
						NI y;
						NI j_135468;
						NI HEX3Atmp_135497;
						NI res_135499;
						i += 1;
						oldlinelen_135454 = (*p).Linelen;
						(*p).I = i;
						scanquote_134922(p, &indent, NIM_TRUE);
						i = (*p).I;
						(*p).Linelen = oldlinelen_135454;
						(*p).I = i;
						LOC46 = scanslice_135113(p, a, aLen0);
						x = LOC46.Field0;
						y = LOC46.Field1;
						i = (*p).I;
						{
							if (!(maxlen < (NI64)((*p).Linelen + a[x]->Sup.len))) goto LA49;
							emitstrlinear_134884(p, s, indent);
						}
						LA49: ;
						emitstr_134897(p, s, a[x]);
						j_135468 = 0;
						HEX3Atmp_135497 = 0;
						HEX3Atmp_135497 = (NI64)(x + 1);
						res_135499 = HEX3Atmp_135497;
						while (1) {
							if (!(res_135499 <= y)) goto LA51;
							j_135468 = res_135499;
							emitstr_134897(p, s, sep);
							{
								if (!(maxlen < (NI64)((*p).Linelen + a[j_135468]->Sup.len))) goto LA54;
								emitstrlinear_134884(p, s, indent);
							}
							LA54: ;
							emitstr_134897(p, s, a[j_135468]);
							res_135499 += 1;
						} LA51: ;
					}
					break;
					default:
					{
						raiseinvalidformat_134633(((NimStringDesc*) &TMP667));
					}
					break;
					}
					goto LA28;
				} LA29: ;
				(*p).I = i;
				LOC57 = scanslice_135113(p, a, aLen0);
				x = LOC57.Field0;
				y = LOC57.Field1;
				i = (*p).I;
				emitstr_134897(p, s, a[x]);
				j_135481 = 0;
				HEX3Atmp_135501 = 0;
				HEX3Atmp_135501 = (NI64)(x + 1);
				res_135503 = HEX3Atmp_135501;
				while (1) {
					if (!(res_135503 <= y)) goto LA58;
					j_135481 = res_135503;
					emitstr_134897(p, s, sep);
					emitstr_134897(p, s, a[j_135481]);
					res_135503 += 1;
				} LA58: ;
			} LA28: ;
		}
		LA16: ;
	}
	break;
	default:
	{
		NI x;
		(*p).I = i;
		x = getformatarg_134678(p, a, aLen0);
		i = (*p).I;
		emitstr_134897(p, s, a[x]);
	}
	break;
	}
	(*p).I = i;
}

N_NIMCALL(void, nfrmtAddf)(NimStringDesc** s, NimStringDesc* formatstr, NimStringDesc** a, NI aLen0) {
	tformatparser134660 p;
	NI i;
	memset((void*)&p, 0, sizeof(p));
	p.F = formatstr->data;
	i = 0;
	while (1) {
		if (!(i < formatstr->Sup.len)) goto LA1;
		{
			if (!((NU8)(p.F[i]) == (NU8)(36))) goto LA4;
			i += 1;
			p.I = i;
			scandollar_134850(&p, a, aLen0, s);
			i = p.I;
		}
		goto LA2;
		LA4: ;
		{
			emitchar_134859(&p, s, p.F[i]);
			i += 1;
		}
		LA2: ;
	} LA1: ;
}

N_NIMCALL(NimStringDesc*, nfrmtFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0) {
	NimStringDesc* result;
	result = 0;
	result = rawNewString((NI64)(formatstr->Sup.len + (NI)((NU64)(aLen0) << (NU64)(4))));
	nfrmtAddf(&result, formatstr, a, aLen0);
	return result;
}

N_NIMCALL(NimStringDesc*, subex_135519)(NimStringDesc* s) {
	NimStringDesc* result;
	result = 0;
	result = copyString(s);
	return result;
}
N_NOINLINE(void, puresubexesInit)(void) {
}

N_NOINLINE(void, puresubexesDatInit)(void) {
static TNimNode TMP36[1];
NTI134631.size = sizeof(einvalidsubex134631);
NTI134631.kind = 17;
NTI134631.base = (&NTI1253);
NTI134631.flags = 2;
TMP36[0].len = 0; TMP36[0].kind = 2;
NTI134631.node = &TMP36[0];
NTI134639.size = sizeof(einvalidsubex134631*);
NTI134639.kind = 22;
NTI134639.base = (&NTI134631);
NTI134639.flags = 2;
NTI134639.marker = TMP658;
}


/* Generated by Nimrod Compiler v0.9.5 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <setjmp.h>

#include <sys/time.h>

#include <stdio.h>
typedef struct globalstate190018 globalstate190018;
typedef struct tstringtable122812 tstringtable122812;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TY110960 TY110960;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TSafePoint TSafePoint;
typedef struct trstgenerator172016 trstgenerator172016;
typedef struct TY172034 TY172034;
typedef struct ttocentry172012 ttocentry172012;
typedef struct trstnode147011 trstnode147011;
typedef struct ttable172052 ttable172052;
typedef struct tkeyvaluepairseq172055 tkeyvaluepairseq172055;
typedef struct tkeyvaluepair172058 tkeyvaluepair172058;
typedef struct tstringstream125366 tstringstream125366;
typedef struct einvalidvalue2855 einvalidvalue2855;
typedef struct esynch2831 esynch2831;
typedef struct tcell43711 tcell43711;
typedef struct tcellseq43727 tcellseq43727;
typedef struct tgcheap45616 tgcheap45616;
typedef struct tcellset43723 tcellset43723;
typedef struct tpagedesc43719 tpagedesc43719;
typedef struct tmemregion26010 tmemregion26010;
typedef struct tsmallchunk25240 tsmallchunk25240;
typedef struct tllchunk26004 tllchunk26004;
typedef struct tbigchunk25242 tbigchunk25242;
typedef struct tintset25217 tintset25217;
typedef struct ttrunk25213 ttrunk25213;
typedef struct tavlnode26008 tavlnode26008;
typedef struct tgcstat45614 tgcstat45614;
typedef struct tcfgparser181814 tcfgparser181814;
typedef struct tbaselexer127014 tbaselexer127014;
typedef struct tstream124835 tstream124835;
typedef struct ttoken181812 ttoken181812;
typedef struct tcfgevent181808 tcfgevent181808;
typedef struct TY95944 TY95944;
typedef struct ttimeinfo95805 ttimeinfo95805;
typedef struct tlogger189036 tlogger189036;
typedef struct trollingfilelogger189042 trollingfilelogger189042;
typedef struct tfilelogger189040 tfilelogger189040;
typedef struct tconsolelogger189038 tconsolelogger189038;
typedef struct tkeyvaluepairseq122810 tkeyvaluepairseq122810;
typedef struct trstnodeseq147009 trstnodeseq147009;
typedef struct tbasechunk25238 tbasechunk25238;
typedef struct tfreecell25230 tfreecell25230;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  globalstate190018  {
tstringtable122812* Config;
NimStringDesc* Lastcconversion;
NimStringDesc* Basedir;
};
struct TY110960 {
NimStringDesc* Field0;
NimStringDesc* Field1;
NimStringDesc* Field2;
};
typedef N_NIMCALL_PTR(void, TY2689) (void* p, NI op);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2689 marker;
};
struct  TNimObject  {
TNimType* m_type;
};
struct  E_Base  {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (E_Base* e, void* ClEnv);
void* ClEnv;
} TY13609;
struct  TSafePoint  {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY13609 raiseAction;
};
struct  ttocentry172012  {
trstnode147011* N;
NimStringDesc* Refname;
NimStringDesc* Header;
};
typedef N_NIMCALL_PTR(NimStringDesc*, tfindfilehandler148023) (NimStringDesc* filename);
typedef N_NIMCALL_PTR(void, tmsghandler148021) (NimStringDesc* filename, NI line, NI col, NU8 msgkind, NimStringDesc* arg);
typedef NimStringDesc* TY172042[5];
struct tkeyvaluepair172058 {
NU8 Field0;
NimStringDesc* Field1;
NI Field2;
};
struct  ttable172052  {
tkeyvaluepairseq172055* Data;
NI Counter;
};
struct  trstgenerator172016  {
  TNimObject Sup;
NU8 Target;
tstringtable122812* Config;
NI Splitafter;
TY172034* Tocpart;
NIM_BOOL Hastoc;
NimStringDesc* Theindex;
NU8 Options;
tfindfilehandler148023 Findfile;
tmsghandler148021 Msghandler;
NimStringDesc* Filename;
TY172042 Meta;
NimStringDesc* Currentsection;
ttable172052 Seenindexterms;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  esynch2831  {
  E_Base Sup;
};
struct  einvalidvalue2855  {
  esynch2831 Sup;
};
struct  tcell43711  {
NI Refcount;
TNimType* Typ;
};
struct  tcellseq43727  {
NI Len;
NI Cap;
tcell43711** D;
};
struct  tcellset43723  {
NI Counter;
NI Max;
tpagedesc43719* Head;
tpagedesc43719** Data;
};
typedef tsmallchunk25240* TY26022[512];
typedef ttrunk25213* ttrunkbuckets25215[256];
struct  tintset25217  {
ttrunkbuckets25215 Data;
};
struct  tmemregion26010  {
NI Minlargeobj;
NI Maxlargeobj;
TY26022 Freesmallchunks;
tllchunk26004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk25242* Freechunkslist;
tintset25217 Chunkstarts;
tavlnode26008* Root;
tavlnode26008* Deleted;
tavlnode26008* Last;
tavlnode26008* Freeavlnodes;
};
struct  tgcstat45614  {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct  tgcheap45616  {
void* Stackbottom;
NI Cyclethreshold;
tcellseq43727 Zct;
tcellseq43727 Decstack;
tcellset43723 Cycleroots;
tcellseq43727 Tempstack;
NI Recgclock;
tmemregion26010 Region;
tgcstat45614 Stat;
};
struct  tbaselexer127014  {
  TNimObject Sup;
NI Bufpos;
NCSTRING Buf;
NI Buflen;
tstream124835* Input;
NI Linenumber;
NI Sentinel;
NI Linestart;
NIM_BOOL Fileopened;
};
struct  ttoken181812  {
NU8 Kind;
NimStringDesc* Literal;
};
struct  tcfgparser181814  {
  tbaselexer127014 Sup;
ttoken181812 Tok;
NimStringDesc* Filename;
};
struct  tcfgevent181808  {
  TNimObject Sup;
NU8 Kind;
union {
struct {NimStringDesc* Section;
} S2;
struct {NimStringDesc* Key;
NimStringDesc* Value;
} S3;
struct {NimStringDesc* Msg;
} S4;
} kindU;
};
typedef NimStringDesc* TY190197[1];
struct TY95944 {
NimStringDesc* Field0;
NimStringDesc* Field1;
};
struct  ttimeinfo95805  {
  TNimObject Sup;
NI Second;
NI Minute;
NI Hour;
NI Monthday;
NU8 Month;
NI Year;
NU8 Weekday;
NI Yearday;
NIM_BOOL Isdst;
NimStringDesc* Tzname;
NI Timezone;
};
typedef NimStringDesc* TY190666[8];
struct  tstringtable122812  {
  TNimObject Sup;
NI Counter;
tkeyvaluepairseq122810* Data;
NU8 Mode;
};
struct  trstnode147011  {
NU8 Kind;
NimStringDesc* Text;
NI Level;
trstnodeseq147009* Sons;
};
typedef N_NIMCALL_PTR(void, TY124836) (tstream124835* s);
typedef N_NIMCALL_PTR(NIM_BOOL, TY124840) (tstream124835* s);
typedef N_NIMCALL_PTR(void, TY124844) (tstream124835* s, NI pos);
typedef N_NIMCALL_PTR(NI, TY124849) (tstream124835* s);
typedef N_NIMCALL_PTR(NI, TY124853) (tstream124835* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY124859) (tstream124835* s, void* buffer, NI buflen);
typedef N_NIMCALL_PTR(void, TY124865) (tstream124835* s);
struct  tstream124835  {
  TNimObject Sup;
TY124836 Closeimpl;
TY124840 Atendimpl;
TY124844 Setpositionimpl;
TY124849 Getpositionimpl;
TY124853 Readdataimpl;
TY124859 Writedataimpl;
TY124865 Flushimpl;
};
struct  tstringstream125366  {
  tstream124835 Sup;
NimStringDesc* Data;
NI Pos;
};
typedef NI TY25220[8];
struct  tpagedesc43719  {
tpagedesc43719* Next;
NI Key;
TY25220 Bits;
};
struct  tbasechunk25238  {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct  tsmallchunk25240  {
  tbasechunk25238 Sup;
tsmallchunk25240* Next;
tsmallchunk25240* Prev;
tfreecell25230* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct  tllchunk26004  {
NI Size;
NI Acc;
tllchunk26004* Next;
};
struct  tbigchunk25242  {
  tbasechunk25238 Sup;
tbigchunk25242* Next;
tbigchunk25242* Prev;
NI Align;
NF Data;
};
struct  ttrunk25213  {
ttrunk25213* Next;
NI Key;
TY25220 Bits;
};
typedef tavlnode26008* TY26014[2];
struct  tavlnode26008  {
TY26014 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct  tlogger189036  {
  TNimObject Sup;
NU8 Levelthreshold;
NimStringDesc* Fmtstr;
};
struct  tfilelogger189040  {
  tlogger189036 Sup;
FILE* F;
};
struct  trollingfilelogger189042  {
  tfilelogger189040 Sup;
NI Maxlines;
NI Curline;
NimStringDesc* Basename;
NI Logfiles;
};
struct  tconsolelogger189038  {
  tlogger189036 Sup;
};
struct  tfreecell25230  {
tfreecell25230* Next;
NI Zerofield;
};
struct TY172034 {
  TGenericSeq Sup;
  ttocentry172012 data[SEQ_DECL_SIZE];
};
struct tkeyvaluepairseq172055 {
  TGenericSeq Sup;
  tkeyvaluepair172058 data[SEQ_DECL_SIZE];
};
struct tkeyvaluepairseq122810 {
  TGenericSeq Sup;
  TY95944 data[SEQ_DECL_SIZE];
};
struct trstnodeseq147009 {
  TGenericSeq Sup;
  trstnode147011* data[SEQ_DECL_SIZE];
};
N_NIMCALL(NI, txt_to_rst)(NCSTRING inputfilename);
N_NIMCALL(NimStringDesc*, cstrToNimstr)(NCSTRING str);
N_NIMCALL(void, nossplitFile)(NimStringDesc* path, TY110960* Result);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
N_NIMCALL(NimStringDesc*, nimfiletohtml_190799)(NimStringDesc* filename);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(NimStringDesc*, nsuRepeatChar)(NI count, NIM_CHAR c);
N_NIMCALL(NI64, nosgetFileSize)(NimStringDesc* file);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, nsuReplaceStr)(NimStringDesc* s, NimStringDesc* sub, NimStringDesc* by);
N_NIMCALL(NimStringDesc*, readfile_11842)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(NimStringDesc*, rststringtohtml_190344)(NimStringDesc* content, NimStringDesc* filename);
N_NIMCALL(tstringtable122812*, loadconfig_190030)(NimStringDesc* memstring);
N_NIMCALL(tstringtable122812*, nstnewStringTable)(NU8 mode);
N_NIMCALL(tstringstream125366*, newstringstream_125487)(NimStringDesc* s);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell43711*, usrtocell_47246)(void* usr);
static N_INLINE(void, rtladdzct_48804)(tcell43711* c);
N_NOINLINE(void, addzct_47217)(tcellseq43727* s, tcell43711* c);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
N_NIMCALL(void, npcopen)(tcfgparser181814* c, tstream124835* input, NimStringDesc* filename, NI lineoffset);
N_NIMCALL(void, npcnext)(tcfgparser181814* c, tcfgevent181808* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, nstPut)(tstringtable122812* t, NimStringDesc* key, NimStringDesc* val);
N_NIMCALL(void, logloop_189370)(NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, npcclose)(tcfgparser181814* c);
static N_INLINE(void, asgnRef)(void** dest, void* src);
static N_INLINE(void, incref_49625)(tcell43711* c);
static N_INLINE(NIM_BOOL, canbecycleroot_47267)(tcell43711* c);
static N_INLINE(void, rtladdcycleroot_48029)(tcell43711* c);
N_NOINLINE(void, incl_44463)(tcellset43723* s, tcell43711* cell);
static N_INLINE(void, decref_49204)(tcell43711* c);
N_NIMCALL(void, nossplitPath)(NimStringDesc* path, TY95944* Result);
N_NIMCALL(void, initrstgenerator_172076)(trstgenerator172016* g, NU8 target, tstringtable122812* config, NimStringDesc* filename, NU8 options, tfindfilehandler148023 findfile, tmsghandler148021 msghandler);
N_NIMCALL(NimStringDesc*, myfindfile_190601)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, HEX2F_110691)(NimStringDesc* head, NimStringDesc* tail);
N_NIMCALL(NIM_BOOL, nosexistsFile)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(void, defaultmsghandler_148807)(NimStringDesc* filename, NI line, NI col, NU8 msgkind, NimStringDesc* arg);
N_NIMCALL(trstnode147011*, rstparse_155356)(NimStringDesc* text, NimStringDesc* filename, NI line, NI column, NIM_BOOL* hastoc, NU8 options, tfindfilehandler148023 findfile, tmsghandler148021 msghandler);
N_NIMCALL(void, renderrsttoout_172543)(trstgenerator172016* d, trstnode147011* n, NimStringDesc** result);
N_NIMCALL(void, getgmtime_95853)(time_t t, ttimeinfo95805* Result);
N_NIMCALL(time_t, nosgetLastModificationTime)(NimStringDesc* file);
N_NIMCALL(NimStringDesc*, nfrmtFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, subex_184691)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nstGet)(tstringtable122812* t, NimStringDesc* key);
N_NIMCALL(NimStringDesc*, format_97821)(ttimeinfo95805* info, NimStringDesc* f);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(E_Base*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
N_NIMCALL(void, reraiseException)(void);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, saferstfiletohtml_190778)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, rstfiletohtml_190679)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, xmlencode_187273)(NimStringDesc* s);
static N_INLINE(NimStringDesc*, getcurrentexceptionmsg_81240)(void);
N_NIMCALL(NimStringDesc*, reprAny)(void* p_79003, TNimType* typ);
N_NIMCALL(NimStringDesc*, addprenumberlines_190689)(NimStringDesc* content);
N_NIMCALL(NI, nsuCountLines)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(NimStringDesc*, nsuAlignString)(NimStringDesc* s, NI count, NIM_CHAR padding);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(void, get_global_html)(void* outputbuffer);
N_NIMCALL(void, quit_82283)(NimStringDesc* errormsg, NI errorcode);
N_NIMCALL(void, log_189309)(trollingfilelogger189042* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
static N_INLINE(NIM_BOOL, isObjWithCache)(TNimType* obj, TNimType* subclass, TNimType** cache);
N_NOINLINE(NIM_BOOL, isobjslowpath_20625)(TNimType* obj, TNimType* subclass, TNimType** cache);
N_NIMCALL(void, log_189169)(tfilelogger189040* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, log_189139)(tconsolelogger189038* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
N_NIMCALL(void, log_189122)(tlogger189036* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0);
static N_INLINE(void, initStackBottom)(void);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
N_NOINLINE(void, systemInit)(void);
N_NOINLINE(void, systemDatInit)(void);
N_NOINLINE(void, stdlib_parseutilsInit)(void);
N_NOINLINE(void, stdlib_parseutilsDatInit)(void);
N_NOINLINE(void, stdlib_strutilsInit)(void);
N_NOINLINE(void, stdlib_strutilsDatInit)(void);
N_NOINLINE(void, stdlib_timesInit)(void);
N_NOINLINE(void, stdlib_timesDatInit)(void);
N_NOINLINE(void, stdlib_posixInit)(void);
N_NOINLINE(void, stdlib_posixDatInit)(void);
N_NOINLINE(void, stdlib_osInit)(void);
N_NOINLINE(void, stdlib_osDatInit)(void);
N_NOINLINE(void, stdlib_hashesInit)(void);
N_NOINLINE(void, stdlib_hashesDatInit)(void);
N_NOINLINE(void, stdlib_strtabsInit)(void);
N_NOINLINE(void, stdlib_strtabsDatInit)(void);
N_NOINLINE(void, stdlib_streamsInit)(void);
N_NOINLINE(void, stdlib_streamsDatInit)(void);
N_NOINLINE(void, stdlib_lexbaseInit)(void);
N_NOINLINE(void, stdlib_lexbaseDatInit)(void);
N_NOINLINE(void, stdlib_unicodeInit)(void);
N_NOINLINE(void, stdlib_unicodeDatInit)(void);
N_NOINLINE(void, stdlib_jsonInit)(void);
N_NOINLINE(void, stdlib_jsonDatInit)(void);
N_NOINLINE(void, HEX00_rstastInit)(void);
N_NOINLINE(void, HEX00_rstastDatInit)(void);
N_NOINLINE(void, HEX00_rstInit)(void);
N_NOINLINE(void, HEX00_rstDatInit)(void);
N_NOINLINE(void, HEX00_highliteInit)(void);
N_NOINLINE(void, HEX00_highliteDatInit)(void);
N_NOINLINE(void, stdlib_mathInit)(void);
N_NOINLINE(void, stdlib_mathDatInit)(void);
N_NOINLINE(void, stdlib_tablesInit)(void);
N_NOINLINE(void, stdlib_tablesDatInit)(void);
N_NOINLINE(void, stdlib_sequtilsInit)(void);
N_NOINLINE(void, stdlib_sequtilsDatInit)(void);
N_NOINLINE(void, stdlib_algorithmInit)(void);
N_NOINLINE(void, stdlib_algorithmDatInit)(void);
N_NOINLINE(void, HEX00_rstgenInit)(void);
N_NOINLINE(void, HEX00_rstgenDatInit)(void);
N_NOINLINE(void, stdlib_parsecfgInit)(void);
N_NOINLINE(void, stdlib_parsecfgDatInit)(void);
N_NOINLINE(void, stdlib_subexesInit)(void);
N_NOINLINE(void, stdlib_subexesDatInit)(void);
N_NOINLINE(void, stdlib_cookiesInit)(void);
N_NOINLINE(void, stdlib_cookiesDatInit)(void);
N_NOINLINE(void, stdlib_cgiInit)(void);
N_NOINLINE(void, stdlib_cgiDatInit)(void);
N_NOINLINE(void, HEX00_loggingInit)(void);
N_NOINLINE(void, HEX00_loggingDatInit)(void);
N_NOINLINE(void, resterInit)(void);
N_NOINLINE(void, resterDatInit)(void);
STRING_LITERAL(TMP97, ".nim", 4);
STRING_LITERAL(TMP107, "\012", 1);
STRING_LITERAL(TMP108, "\012.. code-block:: nimrod\012  ", 26);
STRING_LITERAL(TMP115, "\012  ", 3);
STRING_LITERAL(TMP147, "cannot stream string", 20);
STRING_LITERAL(TMP162, "static slurped config", 21);
STRING_LITERAL(TMP171, "command: ", 9);
STRING_LITERAL(TMP172, ": ", 2);
STRING_LITERAL(TMP173, "# This is the config file for the documentation generator.\012# (c"
") 2012 Andreas Rumpf\012# Feel free to edit the templates as you ne"
"ed.\012\012split.item.toc = \"20\"  \012# too long entries in the table of "
"contents wrap around\012# after this number of characters\012\012doc.sect"
"ion = \"\"\"\012<div class=\"section\" id=\"$sectionID\">\012<h1><a class=\"to"
"c-backref\" href=\"#$sectionTitleID\">$sectionTitle</a></h1>\012<dl cl"
"ass=\"item\">\012$content\012</dl></div>\012\"\"\"\012\012doc.section.toc = \"\"\"\012<li>"
"\012  <a class=\"reference\" href=\"#$sectionID\" id=\"$sectionTitleID\">"
"$sectionTitle</a>\012  <ul class=\"simple\">\012    $content\012  </ul>\012</l"
"i>\012\"\"\"\012\012doc.item = \"\"\"\012<dt id=\"$itemID\"><pre>$header</pre></dt>\012"
"<dd>\012$desc\012</dd>\012\"\"\"\012\012doc.item.toc = \"\"\"\012  <li><a class=\"referen"
"ce\" href=\"#$itemID\">$name</a></li>\012\"\"\"\012\012doc.toc = \"\"\"\012<div class"
"=\"navigation\" id=\"navigation\">\012<ul class=\"simple\">\012$content\012</ul"
">\012</div>\"\"\"\012\012doc.body_toc = \"\"\"\012$tableofcontents\012<div class=\"con"
"tent\" id=\"content\">\012$moduledesc\012$content\012</div>\012\"\"\"\012\012doc.body_no"
"_toc = \"\"\"\012$moduledesc\012$content\012\"\"\"\012\012doc.file = \"\"\"<?xml version"
"=\"1.0\" encoding=\"utf-8\" ?>\012<!DOCTYPE html PUBLIC \"-//W3C//DTD XH"
"TML 1.0 Transitional//EN\"\012  \"http://www.w3.org/TR/xhtml1/DTD/xht"
"ml1-transitional.dtd\">\012<!--  This file is generated by Nimrod. -"
"->\012<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang"
"=\"en\">\012<head>\012<meta http-equiv=\"Content-Type\" content=\"text/html"
"; charset=utf-8\" />\012<title>$title</title>\012<style type=\"text/css\""
">\012\012span.DecNumber {color: blue}\012span.BinNumber {color: blue}\012spa"
"n.HexNumber {color: blue}\012span.OctNumber {color: blue}\012span.Floa"
"tNumber {color: blue}\012span.Identifier  {color: black}\012span.Keywo"
"rd {font-weight: bold}\012span.StringLit {color: blue}\012span.LongStr"
"ingLit {color: blue}\012span.CharLit {color: blue}\012span.EscapeSeque"
"nce {color: black}\012span.Operator {color: black}\012span.Punctation "
"{color: black}\012span.Comment, span.LongComment {font-style:italic"
"; color: green}\012span.RegularExpression  {color: DarkViolet}\012span"
".TagStart {color: DarkViolet}\012span.TagEnd {color: DarkViolet}\012sp"
"an.Key  {color: blue}\012span.Value  {color: black}\012span.RawData {c"
"olor: blue}\012span.Assembler  {color: blue}\012span.Preprocessor {col"
"or: DarkViolet}\012span.Directive  {color: DarkViolet}\012span.Command"
", span.Rule, span.Hyperlink, span.Label, span.Reference, \012span.O"
"ther  {color: black}\012\012div.navigation {\012  -moz-border-radius: 5px"
" 5px 5px 5px;\012  float: left; \012  width: 30%;\012  margin: 0; padding"
": 0;\012  border: 3px outset #7F7F7F;\012  background-color: #7F7F7F;\012"
"}\012\012div.navigation ul {\012  list-style-type: none;\012  padding-left: "
"1em;\012}\012div.navigation ul li a, div.navigation ul li a:visited {\012"
"  font-weight: bold;\012  color: #FFFFFF;\012  text-decoration: none;\012"
"}\012div.navigation ul li a:hover {\012  font-weight: bold;\012  text-dec"
"oration: none;\012  color: gold;\012}\012\012div.content {\012  margin-left: 30"
"%;\012  padding: 0 1em;\012  border-left: 4em;\012}\012\012dl.item dd, dl.item "
"dd p {\012  margin-top:3px;\012}\012dl.item dd pre {\012  margin-left: 15pt;"
"\012  border: 0px;\012}\012dl.item dt, dl.item dt pre {\012  margin:  20pt 0"
" 0 5pt;\012}\012\012pre, span.tok {\012  background-color: #F9F9F9;\012  border"
"-color: #C4C4C4;\012  border-style: solid;\012  border-width: 1px 1px "
"1px 2px;\012  color: black;\012  line-spacing: 110%;\012  padding: 2px;\012}"
"\012\012span.red {\012  color: #A80000;\012}\012\012hr {background-color:#9D9D9D; "
"border:0 none; color:#9D9D9D; height:1px; width:100%;}\012\012/*\012:Auth"
"or: David Goodger\012:Contact: goodger@python.org\012:Date: Date: 2006"
"-05-21 22:44:42 +0200 (Sun, 21 May 2006)\012:Revision: Revision: 45"
"64\012:Copyright: This stylesheet has been placed in the public dom"
"ain.\012\012Default cascading style sheet for the HTML output of Docut"
"ils.\012\012See http://docutils.sf.net/docs/howto/html-stylesheets.htm"
"l for how to\012customize this style sheet.\012*/\012/* used to remove bo"
"rders from tables and images */\012.borderless, table.borderless td"
", table.borderless th { border: 0 }\012\012table.borderless td, table."
"borderless th {\012  /* Override padding for \"table.docutils td\" wi"
"th \"! important\".\012     The right padding separates the table cel"
"ls. */\012  padding: 0 0.5em 0 0 ! important }\012\012.first { margin-top"
": 0 ! important }\012.last, .with-subtitle { margin-bottom: 0 ! imp"
"ortant }\012.hidden { display: none }\012a.toc-backref { text-decorati"
"on: none ; color: black }\012blockquote.epigraph { margin: 2em 5em "
"; }\012dl.docutils dd { margin-bottom: 0.5em }\012div.abstract { margi"
"n: 2em 5em }\012div.abstract p.topic-title { font-weight: bold ; te"
"xt-align: center }\012div.admonition, div.attention, div.caution, d"
"iv.danger, div.error,\012div.hint, div.important, div.note, div.tip"
", div.warning {\012  margin: 2em ; border: medium outset ; padding:"
" 1em }\012div.admonition p.admonition-title, div.hint p.admonition-"
"title,\012div.important p.admonition-title, div.note p.admonition-t"
"itle,\012div.tip p.admonition-title { font-weight: bold ; font-fami"
"ly: sans-serif }\012\012div.attention p.admonition-title, div.caution "
"p.admonition-title,\012div.danger p.admonition-title, div.error p.a"
"dmonition-title,\012div.warning p.admonition-title { color: red ; f"
"ont-weight: bold ;\012  font-family: sans-serif }\012\012/* Uncomment (an"
"d remove this text!) to get reduced vertical space in\012   compoun"
"d paragraphs.\012div.compound .compound-first, div.compound .compou"
"nd-middle {\012  margin-bottom: 0.5em }\012\012div.compound .compound-las"
"t, div.compound .compound-middle {\012  margin-top: 0.5em }\012*/\012\012div"
".dedication { margin: 2em 5em ; text-align: center ; font-style:"
" italic }\012div.dedication p.topic-title { font-weight: bold ; fon"
"t-style: normal }\012div.figure { margin-left: 2em ; margin-right: "
"2em }\012div.footer, div.header { clear: both; font-size: smaller }"
"\012div.line-block { display: block ; margin-top: 1em ; margin-bott"
"om: 1em }\012div.line-block div.line-block { margin-top: 0 ; margin"
"-bottom: 0 ;\012  margin-left: 1.5em }\012div.sidebar { margin-left: 1"
"em ; border: medium outset ;\012  padding: 1em ; background-color: "
"#ffffee ; /*width: 40% ;*/ float: right ;\012  clear: right }\012\012div."
"sidebar p.rubric { font-family: sans-serif ; font-size: medium }"
"\012div.system-messages { margin: 5em }\012div.system-messages h1 { co"
"lor: red }\012div.system-message { border: medium outset ; padding:"
" 1em }\012div.system-message p.system-message-title { color: red ; "
"font-weight: bold }\012div.topic { margin: 2em;}\012h1.section-subtitl"
"e, h2.section-subtitle, h3.section-subtitle,\012h4.section-subtitle"
", h5.section-subtitle, h6.section-subtitle {\012  margin-top: 0.4em"
" }\012h1.title { text-align: center }\012h2.subtitle { text-align: cen"
"ter }\012/* hr.docutils { width: 75% } */\012img.align-left { clear: l"
"eft }\012img.align-right { clear: right }\012ol.simple, ul.simple { ma"
"rgin-bottom: 1em }\012ol.arabic { list-style: decimal }\012ol.loweralp"
"ha { list-style: lower-alpha }\012ol.upperalpha { list-style: upper"
"-alpha }\012ol.lowerroman { list-style: lower-roman }\012ol.upperroman"
" { list-style: upper-roman }\012p.attribution { text-align: right ;"
" margin-left: 50% }\012p.caption { font-style: italic }\012p.credits {"
" font-style: italic ; font-size: smaller }\012p.label { white-space"
": nowrap }\012p.rubric { font-weight:bold;font-size:larger;color:ma"
"roon;text-align:center}\012p.sidebar-title {font-family: sans-serif"
" ;font-weight: bold ;font-size: larger }\012p.sidebar-subtitle {fon"
"t-family: sans-serif ; font-weight: bold }\012p.topic-title {\012font-"
"weight: bold;\012background-color: #6D6D6D;\012border-bottom: 1px soli"
"d #000000;\012border-top: 1px solid black;\012color: white;\012text-align"
": center;\012margin: 0;\012}\012pre.address { margin-bottom: 0;margin-top"
":0;font-family:serif;font-size:100% }\012pre.literal-block, pre.doc"
"test-block {margin-left: 2em ;margin-right: 2em }\012span.classifie"
"r {font-family: sans-serif;font-style: oblique }\012span.classifier"
"-delimiter {font-family: sans-serif;font-weight: bold }\012span.int"
"erpreted {font-family: sans-serif }\012span.option {white-space: no"
"wrap }\012span.pre {white-space: pre }\012span.problematic {color: red"
" }\012span.section-subtitle {\012  /* font-size relative to parent (h1"
"..h6 element) */\012  font-size: 80% }\012\012table.citation { border-lef"
"t: solid 1px gray; margin-left: 1px }\012table.docinfo {margin: 2em"
" 4em }\012table.docutils {margin-top: 0.5em;margin-bottom: 0.5em; b"
"order: 0 solid #9d9d9d; border-collapse: collapse; }\012table.footn"
"ote {border-left: solid 1px black;margin-left: 1px }\012\012table.docu"
"tils td, table.docutils th,\012table.docinfo td, table.docinfo th {"
"padding-left: 0.5em;padding-right: 0.5em;\012  vertical-align: top;"
"}\012\012table.docutils td, table.docutils th { border-bottom:1px soli"
"d #9D9D9D; }\012/* color: #4d4d4d} */\012\012/* table.docutils td:hover, "
"table.docinfo td:hover {color: #000000} */\012  \012\012table.docutils th"
".field-name, table.docinfo th.docinfo-name {\012  font-weight: bold"
";text-align: left;white-space: nowrap;padding-left: 0 }\012  \012table"
".docutils th\012{\012color: black;\012font-weight:normal;\012background-colo"
"r: #E3E3E3;\012border-top: 1px solid #1d1d1d;\012border-bottom: 1px so"
"lid #1d1d1d;\012}\012  \012h1 tt.docutils, h2 tt.docutils, h3 tt.docutils"
",\012h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {font-size: 100"
"% }\012ul.auto-toc { list-style-type: none }\012/*a.reference { color:"
" #E00000; font-weight:bold;}\012a.reference:hover {color: #E00000;b"
"ackground-color: #ffff00;display: margin;\012  font-weight:bold;}*/"
"\012\012</style>\012\012</head>\012<body>\012<div class=\"document\" id=\"documentId\""
">\012<h1 class=\"title\">$title</h1>\012$content\012<small>Last modified: $"
"date $time UTC</small>\012</div>\012</body>\012</html>\012\"\"\"\012", 9073);
STRING_LITERAL(TMP186, "Asking for \'", 12);
STRING_LITERAL(TMP187, "\'", 1);
STRING_LITERAL(TMP188, "Global is \'", 11);
STRING_LITERAL(TMP189, "Returning \'", 11);
STRING_LITERAL(TMP190, "", 0);
STRING_LITERAL(TMP699, "doc.file", 8);
STRING_LITERAL(TMP700, "title", 5);
STRING_LITERAL(TMP701, "date", 4);
STRING_LITERAL(TMP754, "yyyy-MM-dd", 10);
STRING_LITERAL(TMP755, "time", 4);
STRING_LITERAL(TMP756, "HH:MM", 5);
STRING_LITERAL(TMP757, "content", 7);
STRING_LITERAL(TMP758, "<html><body><h1>Error for ", 26);
STRING_LITERAL(TMP759, "</h1></body></html>", 19);
STRING_LITERAL(TMP760, "<html><body><h1>OS error for ", 29);
STRING_LITERAL(TMP761, "<html><body><h1>I/O error for ", 30);
STRING_LITERAL(TMP762, "<html><body><h1>Out of memory!</h1></body></html>", 49);
STRING_LITERAL(TMP769, "Could not read ", 15);
STRING_LITERAL(TMP770, "!!!", 3);
STRING_LITERAL(TMP771, "<html><body><b>Sorry! Error parsing ", 36);
STRING_LITERAL(TMP772, " with version 0.4.1.</b><p>If possible please report it at <a h"
"ref=\"https://github.com/gradha/quicklook-rest-with-nimrod/issues"
"\">https://github.com/gradha/quicklook-rest-with-nimrod/issues</a"
"><p>", 195);
STRING_LITERAL(TMP795, " with message \'", 15);
STRING_LITERAL(TMP796, "\'</p><p>Displaying raw contents of file anyway:</p><p><pre>", 59);
STRING_LITERAL(TMP797, " ", 1);
STRING_LITERAL(TMP798, "<br>", 4);
STRING_LITERAL(TMP799, "</pre></p></body></html>", 24);
STRING_LITERAL(TMP800, "Uh oh, wrong API usage", 22);
globalstate190018 g_190025;
extern TSafePoint* exchandler_15043;
extern TNimType NTI148013; /* TRstParseOption */
TNimType NTI190349; /* set[TRstParseOption] */
extern TNimType NTI172016; /* TRstGenerator */
extern TNimType NTI20201; /* ref EInvalidValue */
extern TNimType NTI2855; /* EInvalidValue */
extern tgcheap45616 gch_45644;
extern TNimType NTI181814; /* TCfgParser */
extern TNimType NTI181808; /* TCfgEvent */
extern NU8 level_189342;
extern TNimType NTI95805; /* TTimeInfo */
extern TNimType NTI2827; /* E_Base */
extern E_Base* currexception_15045;
extern TNimType NTI2837; /* EOS */
extern TNimType NTI2835; /* EIO */
extern TNimType NTI2859; /* EOutOfMemory */
extern TNimType NTI7828; /* ref E_Base */
extern TNimType NTI189042; /* TRollingFileLogger */
extern TNimType NTI189040; /* TFileLogger */
static TNimType* Nim_OfCheck_CACHE1[2];
extern TNimType NTI189038; /* TConsoleLogger */
extern TNimType NTI189036; /* TLogger */
static TNimType* Nim_OfCheck_CACHE2[2];

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
	int LOC13;
	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = 0;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = 0;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC13 = 0;
	LOC13 = memcmp(((NCSTRING) ((*a).data)), ((NCSTRING) ((*b).data)), (NI64)((*a).Sup.len * 1));
	LOC11 = (LOC13 == ((NI32) 0));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_15043;
	exchandler_15043 = s;
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(tcell43711*, usrtocell_47246)(void* usr) {
	tcell43711* result;
	result = 0;
	result = ((tcell43711*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell43711))))));
	return result;
}

static N_INLINE(void, rtladdzct_48804)(tcell43711* c) {
	addzct_47217(&gch_45644.Zct, c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell43711* c;
	c = usrtocell_47246(p);
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_48804(c);
	}
	LA3: ;
}

N_NIMCALL(tstringtable122812*, loadconfig_190030)(NimStringDesc* memstring) {
	tstringtable122812* result;
	tstringstream125366* f;
	tcfgparser181814 p;
	result = 0;
	result = nstnewStringTable(((NU8) 2));
	f = newstringstream_125487(memstring);
	{
		einvalidvalue2855* e_190048;
		NimStringDesc* LOC5;
		if (!f == 0) goto LA3;
		e_190048 = 0;
		e_190048 = (einvalidvalue2855*) newObj((&NTI20201), sizeof(einvalidvalue2855));
		(*e_190048).Sup.Sup.Sup.m_type = (&NTI2855);
		LOC5 = 0;
		LOC5 = (*e_190048).Sup.Sup.message; (*e_190048).Sup.Sup.message = copyStringRC1(((NimStringDesc*) &TMP147));
		if (LOC5) nimGCunrefNoCycle(LOC5);
		raiseException((E_Base*)e_190048, "EInvalidValue");
	}
	LA3: ;
	memset((void*)&p, 0, sizeof(p));
	p.Sup.Sup.m_type = (&NTI181814);
	npcopen(&p, &f->Sup, ((NimStringDesc*) &TMP162), 0);
	while (1) {
		tcfgevent181808 e_190069;
		chckNil((void*)&e_190069);
		memset((void*)&e_190069, 0, sizeof(e_190069));
		e_190069.Sup.m_type = (&NTI181808);
		npcnext(&p, &e_190069);
		switch (e_190069.Kind) {
		case ((NU8) 0):
		{
			goto LA6;
		}
		break;
		case ((NU8) 1):
		{
		}
		break;
		case ((NU8) 2):
		{
			nstPut(result, e_190069.kindU.S3.Key, e_190069.kindU.S3.Value);
		}
		break;
		case ((NU8) 3):
		{
			{
				NimStringDesc* LOC15;
				TY190197 LOC16;
				if (!(level_189342 <= ((NU8) 3))) goto LA13;
				LOC15 = 0;
				LOC15 = rawNewString(e_190069.kindU.S3.Key->Sup.len + e_190069.kindU.S3.Value->Sup.len + 11);
appendString(LOC15, ((NimStringDesc*) &TMP171));
appendString(LOC15, e_190069.kindU.S3.Key);
appendString(LOC15, ((NimStringDesc*) &TMP172));
appendString(LOC15, e_190069.kindU.S3.Value);
				memset((void*)LOC16, 0, sizeof(LOC16));
				logloop_189370(((NU8) 3), LOC15, LOC16, 0);
			}
			LA13: ;
		}
		break;
		case ((NU8) 4):
		{
			einvalidvalue2855* e_190272;
			NimStringDesc* LOC23;
			{
				TY190197 LOC22;
				if (!(level_189342 <= ((NU8) 4))) goto LA20;
				memset((void*)LOC22, 0, sizeof(LOC22));
				logloop_189370(((NU8) 4), e_190069.kindU.S4.Msg, LOC22, 0);
			}
			LA20: ;
			e_190272 = 0;
			e_190272 = (einvalidvalue2855*) newObj((&NTI20201), sizeof(einvalidvalue2855));
			(*e_190272).Sup.Sup.Sup.m_type = (&NTI2855);
			LOC23 = 0;
			LOC23 = (*e_190272).Sup.Sup.message; (*e_190272).Sup.Sup.message = copyStringRC1(e_190069.kindU.S4.Msg);
			if (LOC23) nimGCunrefNoCycle(LOC23);
			raiseException((E_Base*)e_190272, "EInvalidValue");
		}
		break;
		}
	} LA6: ;
	npcclose(&p);
	return result;
}

static N_INLINE(NIM_BOOL, canbecycleroot_47267)(tcell43711* c) {
	NIM_BOOL result;
	result = 0;
	result = !((((*(*c).Typ).flags &(1<<((((NU8) 1))&7)))!=0));
	return result;
}

static N_INLINE(void, rtladdcycleroot_48029)(tcell43711* c) {
	{
		if (!!((((NI) ((NI)((*c).Refcount & 3))) == 3))) goto LA3;
		(*c).Refcount = (NI)((NI)((*c).Refcount & -4) | 3);
		incl_44463(&gch_45644.Cycleroots, c);
	}
	LA3: ;
}

static N_INLINE(void, incref_49625)(tcell43711* c) {
	(*c).Refcount = (NI)((NU64)((*c).Refcount) + (NU64)(8));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = canbecycleroot_47267(c);
		if (!LOC3) goto LA4;
		rtladdcycleroot_48029(c);
	}
	LA4: ;
}

static N_INLINE(void, decref_49204)(tcell43711* c) {
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_48804(c);
	}
	goto LA1;
	LA3: ;
	{
		NIM_BOOL LOC6;
		LOC6 = 0;
		LOC6 = canbecycleroot_47267(c);
		if (!LOC6) goto LA7;
		rtladdcycleroot_48029(c);
	}
	goto LA1;
	LA7: ;
	LA1: ;
}

static N_INLINE(void, asgnRef)(void** dest, void* src) {
	{
		tcell43711* LOC5;
		if (!!((src == NIM_NIL))) goto LA3;
		LOC5 = 0;
		LOC5 = usrtocell_47246(src);
		incref_49625(LOC5);
	}
	LA3: ;
	{
		tcell43711* LOC10;
		if (!!(((*dest) == NIM_NIL))) goto LA8;
		LOC10 = 0;
		LOC10 = usrtocell_47246((*dest));
		decref_49204(LOC10);
	}
	LA8: ;
	(*dest) = src;
}

N_NIMCALL(NimStringDesc*, myfindfile_190601)(NimStringDesc* filename) {
	NimStringDesc* result;
	result = 0;
	{
		NimStringDesc* LOC5;
		TY190197 LOC6;
		if (!(level_189342 <= ((NU8) 1))) goto LA3;
		LOC5 = 0;
		LOC5 = rawNewString(filename->Sup.len + 13);
appendString(LOC5, ((NimStringDesc*) &TMP186));
appendString(LOC5, filename);
appendString(LOC5, ((NimStringDesc*) &TMP187));
		memset((void*)LOC6, 0, sizeof(LOC6));
		logloop_189370(((NU8) 1), LOC5, LOC6, 0);
	}
	LA3: ;
	{
		NimStringDesc* LOC11;
		TY190197 LOC12;
		if (!(level_189342 <= ((NU8) 1))) goto LA9;
		LOC11 = 0;
		LOC11 = rawNewString(g_190025.Basedir->Sup.len + 12);
appendString(LOC11, ((NimStringDesc*) &TMP188));
appendString(LOC11, g_190025.Basedir);
appendString(LOC11, ((NimStringDesc*) &TMP187));
		memset((void*)LOC12, 0, sizeof(LOC12));
		logloop_189370(((NU8) 1), LOC11, LOC12, 0);
	}
	LA9: ;
	{
		if (!(0 < g_190025.Basedir->Sup.len)) goto LA15;
		result = HEX2F_110691(g_190025.Basedir, filename);
		{
			NIM_BOOL LOC19;
			LOC19 = 0;
			LOC19 = nosexistsFile(result);
			if (!LOC19) goto LA20;
			{
				NimStringDesc* LOC26;
				TY190197 LOC27;
				if (!(level_189342 <= ((NU8) 1))) goto LA24;
				LOC26 = 0;
				LOC26 = rawNewString(result->Sup.len + 12);
appendString(LOC26, ((NimStringDesc*) &TMP189));
appendString(LOC26, result);
appendString(LOC26, ((NimStringDesc*) &TMP187));
				memset((void*)LOC27, 0, sizeof(LOC27));
				logloop_189370(((NU8) 1), LOC26, LOC27, 0);
			}
			LA24: ;
			goto BeforeRet;
		}
		LA20: ;
	}
	LA15: ;
	{
		NIM_BOOL LOC30;
		LOC30 = 0;
		LOC30 = nosexistsFile(filename);
		if (!LOC30) goto LA31;
		result = copyString(filename);
	}
	goto LA28;
	LA31: ;
	{
		result = copyString(((NimStringDesc*) &TMP190));
	}
	LA28: ;
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, rststringtohtml_190344)(NimStringDesc* content, NimStringDesc* filename) {
	NimStringDesc* result;
	NU8 parseoptions;
	trstgenerator172016 generator;
	NIM_BOOL hastoc;
	TY95944 LOC5;
	NimStringDesc* LOC6;
	trstnode147011* rst;
	NimStringDesc* moddesc;
	ttimeinfo95805 lastmod;
	time_t LOC7;
	NimStringDesc* title;
	NimStringDesc* LOC8;
	NimStringDesc* LOC9;
	TY190666 LOC10;
	result = 0;
	parseoptions = 4;
	memset((void*)&generator, 0, sizeof(generator));
	generator.Sup.m_type = (&NTI172016);
	hastoc = 0;
	{
		if (!g_190025.Config == 0) goto LA3;
		asgnRef((void**) &g_190025.Config, loadconfig_190030(((NimStringDesc*) &TMP173)));
	}
	LA3: ;
	memset((void*)&LOC5, 0, sizeof(LOC5));
	nossplitPath(filename, &LOC5);
	LOC6 = 0;
	LOC6 = g_190025.Basedir; g_190025.Basedir = copyStringRC1(LOC5.Field0);
	if (LOC6) nimGCunrefNoCycle(LOC6);
	initrstgenerator_172076(&generator, ((NU8) 0), g_190025.Config, filename, parseoptions, myfindfile_190601, defaultmsghandler_148807);
	rst = rstparse_155356(content, filename, 1, 1, &hastoc, parseoptions, myfindfile_190601, NIM_NIL);
	result = rawNewString(30000);
	moddesc = rawNewString(30000);
	renderrsttoout_172543(&generator, rst, &moddesc);
	LOC7 = 0;
	LOC7 = nosgetLastModificationTime(filename);
	chckNil((void*)&lastmod);
	memset((void*)&lastmod, 0, sizeof(lastmod));
	lastmod.Sup.m_type = (&NTI95805);
	getgmtime_95853(LOC7, &lastmod);
	title = copyString(generator.Meta[(((NU8) 1))- 0]);
	LOC8 = 0;
	LOC8 = nstGet(g_190025.Config, ((NimStringDesc*) &TMP699));
	LOC9 = 0;
	LOC9 = subex_184691(LOC8);
	memset((void*)LOC10, 0, sizeof(LOC10));
	LOC10[0] = copyString(((NimStringDesc*) &TMP700));
	LOC10[1] = copyString(title);
	LOC10[2] = copyString(((NimStringDesc*) &TMP701));
	LOC10[3] = format_97821(&lastmod, ((NimStringDesc*) &TMP754));
	LOC10[4] = copyString(((NimStringDesc*) &TMP755));
	LOC10[5] = format_97821(&lastmod, ((NimStringDesc*) &TMP756));
	LOC10[6] = copyString(((NimStringDesc*) &TMP757));
	LOC10[7] = copyString(moddesc);
	result = nfrmtFormatOpenArray(LOC9, LOC10, 8);
	return result;
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_15043 = (*exchandler_15043).prev;
}

static N_INLINE(E_Base*, getCurrentException)(void) {
	E_Base* result;
	result = 0;
	result = currexception_15045;
	return result;
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRef((void**) &currexception_15045, (*currexception_15045).parent);
}

N_NIMCALL(NimStringDesc*, nimfiletohtml_190799)(NimStringDesc* filename) {
	NimStringDesc* result;
	TSafePoint TMP98;
	result = 0;
	pushSafePoint(&TMP98);
	TMP98.status = setjmp(TMP98.context);
	if (TMP98.status == 0) {
		NimStringDesc* volatile name;
		TY110960 LOC2;
		NimStringDesc* volatile titlesymbols;
		NI volatile length;
		NI64 LOC3;
		NimStringDesc* volatile source;
		NimStringDesc* LOC4;
		NimStringDesc* LOC5;
		NimStringDesc* LOC6;
		memset((void*)&LOC2, 0, sizeof(LOC2));
		nossplitFile(filename, &LOC2);
		name = LOC2.Field1;
		titlesymbols = nsuRepeatChar(name->Sup.len, 61);
		LOC3 = 0;
		LOC3 = nosgetFileSize(filename);
		length = (NI64)(1000 + ((NI) (LOC3)));
		source = rawNewString(length);
		LOC4 = 0;
		LOC4 = rawNewString(titlesymbols->Sup.len + name->Sup.len + titlesymbols->Sup.len + 28);
appendString(LOC4, titlesymbols);
appendString(LOC4, ((NimStringDesc*) &TMP107));
appendString(LOC4, name);
appendString(LOC4, ((NimStringDesc*) &TMP107));
appendString(LOC4, titlesymbols);
appendString(LOC4, ((NimStringDesc*) &TMP108));
		source = LOC4;
		LOC5 = 0;
		LOC5 = readfile_11842(filename);
		LOC6 = 0;
		LOC6 = nsuReplaceStr(LOC5, ((NimStringDesc*) &TMP107), ((NimStringDesc*) &TMP115));
		source = resizeString(source, LOC6->Sup.len + 0);
appendString(source, LOC6);
		result = rststringtohtml_190344(source, filename);
		popSafePoint();
	}
	else {
		popSafePoint();
		if (isObj(getCurrentException()->Sup.m_type, (&NTI2827))) {
			NimStringDesc* LOC9;
			TMP98.status = 0;
			LOC9 = 0;
			LOC9 = rawNewString(filename->Sup.len + 45);
appendString(LOC9, ((NimStringDesc*) &TMP758));
appendString(LOC9, filename);
appendString(LOC9, ((NimStringDesc*) &TMP759));
			result = LOC9;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI2837))) {
			NimStringDesc* LOC11;
			TMP98.status = 0;
			LOC11 = 0;
			LOC11 = rawNewString(filename->Sup.len + 48);
appendString(LOC11, ((NimStringDesc*) &TMP760));
appendString(LOC11, filename);
appendString(LOC11, ((NimStringDesc*) &TMP759));
			result = LOC11;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI2835))) {
			NimStringDesc* LOC13;
			TMP98.status = 0;
			LOC13 = 0;
			LOC13 = rawNewString(filename->Sup.len + 49);
appendString(LOC13, ((NimStringDesc*) &TMP761));
appendString(LOC13, filename);
appendString(LOC13, ((NimStringDesc*) &TMP759));
			result = LOC13;
			popCurrentException();
		}
		else 		if (isObj(getCurrentException()->Sup.m_type, (&NTI2859))) {
			TMP98.status = 0;
			result = copyString(((NimStringDesc*) &TMP762));
			popCurrentException();
		}
	}
	if (TMP98.status != 0) reraiseException();
	return result;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell43711* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_47246(src);
		(*c).Refcount += 8;
	}
	LA3: ;
	{
		tcell43711* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_47246((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_48804(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(NimStringDesc*, rstfiletohtml_190679)(NimStringDesc* filename) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = readfile_11842(filename);
	result = rststringtohtml_190344(LOC1, filename);
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(NimStringDesc*, getcurrentexceptionmsg_81240)(void) {
	NimStringDesc* result;
	E_Base* e;
	result = 0;
	e = getCurrentException();
	{
		if (!(e == NIM_NIL)) goto LA3;
		result = copyString(((NimStringDesc*) &TMP190));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString((*e).message);
	}
	LA1: ;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, addprenumberlines_190689)(NimStringDesc* content) {
	NimStringDesc* result;
	NI maxlines;
	NI LOC1;
	NI width;
	NimStringDesc* LOC2;
	NI i;
	NI line;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	result = 0;
	LOC1 = 0;
	LOC1 = nsuCountLines(content);
	maxlines = (NI64)(1 + LOC1);
	LOC2 = 0;
	LOC2 = nimIntToStr(maxlines);
	width = LOC2->Sup.len;
	result = rawNewString((NI64)(content->Sup.len + (NI64)(width * maxlines)));
	i = 0;
	line = 1;
	LOC3 = 0;
	LOC3 = nimIntToStr(line);
	LOC4 = 0;
	LOC4 = nsuAlignString(LOC3, width, 32);
	result = resizeString(result, LOC4->Sup.len + 0);
appendString(result, LOC4);
	result = resizeString(result, 1);
appendString(result, ((NimStringDesc*) &TMP797));
	while (1) {
		if (!(i < (NI64)(content->Sup.len - 1))) goto LA5;
		result = addChar(result, content->data[i]);
		switch (((NU8)(content->data[i]))) {
		case 13:
		case 10:
		{
			NimStringDesc* LOC13;
			NimStringDesc* LOC14;
			{
				NIM_BOOL LOC9;
				LOC9 = 0;
				LOC9 = ((NU8)(content->data[i]) == (NU8)(13));
				if (!(LOC9)) goto LA10;
				LOC9 = ((NU8)(content->data[(NI64)(i + 1)]) == (NU8)(10));
				LA10: ;
				if (!LOC9) goto LA11;
				i += 1;
			}
			LA11: ;
			line += 1;
			LOC13 = 0;
			LOC13 = nimIntToStr(line);
			LOC14 = 0;
			LOC14 = nsuAlignString(LOC13, width, 32);
			result = resizeString(result, LOC14->Sup.len + 0);
appendString(result, LOC14);
			result = resizeString(result, 1);
appendString(result, ((NimStringDesc*) &TMP797));
		}
		break;
		default:
		{
		}
		break;
		}
		i += 1;
	} LA5: ;
	{
		if (!(((NU8)(content->data[content->Sup.len - 1])) == ((NU8)(13)) || ((NU8)(content->data[content->Sup.len - 1])) == ((NU8)(10)))) goto LA18;
	}
	goto LA16;
	LA18: ;
	{
		result = addChar(result, content->data[content->Sup.len - 1]);
	}
	LA16: ;
	return result;
}

N_NIMCALL(NimStringDesc*, saferstfiletohtml_190778)(NimStringDesc* filename) {
	NimStringDesc* result;
	TSafePoint TMP763;
	result = 0;
	pushSafePoint(&TMP763);
	TMP763.status = setjmp(TMP763.context);
	if (TMP763.status == 0) {
		result = rstfiletohtml_190679(filename);
		popSafePoint();
	}
	else {
		popSafePoint();
		{
			NimStringDesc* volatile content;
			TSafePoint TMP764;
			E_Base* volatile e;
			NimStringDesc* volatile msg;
			NimStringDesc* LOC9;
			NimStringDesc* LOC10;
			NimStringDesc* LOC11;
			NimStringDesc* LOC12;
			NimStringDesc* LOC13;
			NimStringDesc* LOC14;
			TMP763.status = 0;
			content = 0;
			pushSafePoint(&TMP764);
			TMP764.status = setjmp(TMP764.context);
			if (TMP764.status == 0) {
				NimStringDesc* LOC5;
				LOC5 = 0;
				LOC5 = readfile_11842(filename);
				content = xmlencode_187273(LOC5);
				popSafePoint();
			}
			else {
				popSafePoint();
				if (isObj(getCurrentException()->Sup.m_type, (&NTI2827))) {
					NimStringDesc* LOC8;
					TMP764.status = 0;
					LOC8 = 0;
					LOC8 = rawNewString(filename->Sup.len + 18);
appendString(LOC8, ((NimStringDesc*) &TMP769));
appendString(LOC8, filename);
appendString(LOC8, ((NimStringDesc*) &TMP770));
					content = LOC8;
					popCurrentException();
				}
			}
			if (TMP764.status != 0) reraiseException();
			e = getCurrentException();
			msg = getcurrentexceptionmsg_81240();
			LOC9 = 0;
			LOC10 = 0;
			LOC10 = xmlencode_187273(filename);
			LOC11 = 0;
			LOC11 = xmlencode_187273(reprAny(e, (&NTI7828)));
			LOC12 = 0;
			LOC12 = xmlencode_187273(msg);
			LOC13 = 0;
			LOC13 = addprenumberlines_190689(content);
			LOC14 = 0;
			LOC14 = nsuReplaceStr(LOC13, ((NimStringDesc*) &TMP107), ((NimStringDesc*) &TMP798));
			LOC9 = rawNewString(LOC10->Sup.len + LOC11->Sup.len + LOC12->Sup.len + LOC14->Sup.len + 329);
appendString(LOC9, ((NimStringDesc*) &TMP771));
appendString(LOC9, LOC10);
appendString(LOC9, ((NimStringDesc*) &TMP772));
appendString(LOC9, LOC11);
appendString(LOC9, ((NimStringDesc*) &TMP795));
appendString(LOC9, LOC12);
appendString(LOC9, ((NimStringDesc*) &TMP796));
appendString(LOC9, LOC14);
appendString(LOC9, ((NimStringDesc*) &TMP799));
			result = LOC9;
			popCurrentException();
		}
	}
	if (TMP763.status != 0) reraiseException();
	return result;
}

N_NIMCALL(NI, txt_to_rst)(NCSTRING inputfilename) {
	NI result;
	NimStringDesc* filename;
	TY110960 LOC1;
	result = 0;
	filename = cstrToNimstr(inputfilename);
	memset((void*)&LOC1, 0, sizeof(LOC1));
	nossplitFile(filename, &LOC1);
	if (eqStrings(LOC1.Field2, ((NimStringDesc*) &TMP97))) goto LA2;
	goto LA3;
	LA2: ;
	{
		asgnRefNoCycle((void**) &g_190025.Lastcconversion, nimfiletohtml_190799(filename));
	}
	goto LA4;
	LA3: ;
	{
		asgnRefNoCycle((void**) &g_190025.Lastcconversion, saferstfiletohtml_190778(filename));
	}
	LA4: ;
	result = g_190025.Lastcconversion->Sup.len;
	return result;
}

N_NIMCALL(void, get_global_html)(void* outputbuffer) {
	{
		if (!g_190025.Lastcconversion == 0) goto LA3;
		quit_82283(((NimStringDesc*) &TMP800), 1);
	}
	LA3: ;
	memcpy(outputbuffer, ((void*) (&g_190025.Lastcconversion->data[0])), g_190025.Lastcconversion->Sup.len);
}

static N_INLINE(NIM_BOOL, isObjWithCache)(TNimType* obj, TNimType* subclass, TNimType** cache) {
	NIM_BOOL result;
	result = 0;
	{
		if (!(obj == subclass)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		if (!((*obj).base == subclass)) goto LA7;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA7: ;
	{
		if (!(cache[(0)- 0] == obj)) goto LA11;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA11: ;
	{
		if (!(cache[(1)- 0] == obj)) goto LA15;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA15: ;
	result = isobjslowpath_20625(obj, subclass, cache);
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, log_189134)(tlogger189036* l, NU8 level, NimStringDesc* frmt, NimStringDesc** args, NI argsLen0) {
	{
		if (!((l) && ((*l).Sup.m_type == (&NTI189042)))) goto LA3;
		log_189309(((trollingfilelogger189042*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA3: ;
	{
		if (!((l) && (isObjWithCache((*l).Sup.m_type, (&NTI189040), Nim_OfCheck_CACHE1)))) goto LA6;
		log_189169(((tfilelogger189040*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA6: ;
	{
		if (!((l) && ((*l).Sup.m_type == (&NTI189038)))) goto LA9;
		log_189139(((tconsolelogger189038*) (l)), level, frmt, args, argsLen0);
	}
	goto LA1;
	LA9: ;
	{
		if (!((l) && (isObjWithCache((*l).Sup.m_type, (&NTI189036), Nim_OfCheck_CACHE2)))) goto LA12;
		log_189122(l, level, frmt, args, argsLen0);
	}
	goto LA1;
	LA12: ;
	LA1: ;
}

static N_INLINE(void, initStackBottom)(void) {
	void* volatile locals;
	locals = 0;
	locals = ((void*) (&locals));
	setStackBottom(locals);
}
void PreMain() {
	systemDatInit();
	systemInit();
	stdlib_parseutilsDatInit();
	stdlib_strutilsDatInit();
	stdlib_timesDatInit();
	stdlib_posixDatInit();
	stdlib_osDatInit();
	stdlib_hashesDatInit();
	stdlib_strtabsDatInit();
	stdlib_streamsDatInit();
	stdlib_lexbaseDatInit();
	stdlib_unicodeDatInit();
	stdlib_jsonDatInit();
	HEX00_rstastDatInit();
	HEX00_rstDatInit();
	HEX00_highliteDatInit();
	stdlib_mathDatInit();
	stdlib_tablesDatInit();
	stdlib_sequtilsDatInit();
	stdlib_algorithmDatInit();
	HEX00_rstgenDatInit();
	stdlib_parsecfgDatInit();
	stdlib_subexesDatInit();
	stdlib_cookiesDatInit();
	stdlib_cgiDatInit();
	HEX00_loggingDatInit();
	resterDatInit();
	initStackBottom();
	stdlib_parseutilsInit();
	stdlib_strutilsInit();
	stdlib_timesInit();
	stdlib_posixInit();
	stdlib_osInit();
	stdlib_hashesInit();
	stdlib_strtabsInit();
	stdlib_streamsInit();
	stdlib_lexbaseInit();
	stdlib_unicodeInit();
	stdlib_jsonInit();
	HEX00_rstastInit();
	HEX00_rstInit();
	HEX00_highliteInit();
	stdlib_mathInit();
	stdlib_tablesInit();
	stdlib_sequtilsInit();
	stdlib_algorithmInit();
	HEX00_rstgenInit();
	stdlib_parsecfgInit();
	stdlib_subexesInit();
	stdlib_cookiesInit();
	stdlib_cgiInit();
	HEX00_loggingInit();
}

int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMain)(void) {
	PreMain();
	resterInit();
}

N_NOINLINE(void, resterInit)(void) {
}

N_NOINLINE(void, resterDatInit)(void) {
static TNimNode TMP5[1];
NTI190349.size = sizeof(NU8);
NTI190349.kind = 19;
NTI190349.base = (&NTI148013);
NTI190349.flags = 3;
TMP5[0].len = 0; TMP5[0].kind = 0;
NTI190349.node = &TMP5[0];
}

